<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>flyingzc&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-14T05:01:10.161Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>flyingzc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spring-boot EnableAutoConfiguration</title>
    <link href="http://yoursite.com/2020/06/14/01no/springboot/springboot03-EnableAutoConfiguration/"/>
    <id>http://yoursite.com/2020/06/14/01no/springboot/springboot03-EnableAutoConfiguration/</id>
    <published>2020-06-13T16:00:00.000Z</published>
    <updated>2020-06-14T05:01:10.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-boot-EnableAutoConfiguration"><a href="#spring-boot-EnableAutoConfiguration" class="headerlink" title="spring-boot EnableAutoConfiguration"></a>spring-boot EnableAutoConfiguration</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- refresh() -&gt; invokeBeanFactoryPostProcessors()</span><br><span class="line">- ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry()</span><br><span class="line">    - ConfigurationClassPostProcessor.processConfigBeanDefinitions()</span><br><span class="line">    - 1.parser.parse(candidates)比如此时candidates是SpringApplication启动类</span><br><span class="line">        - ConfigurationClassParser.parse()</span><br><span class="line">        - 1.不同类型的 beanDefinition,调用不同的 parse(),parse()方法 -&gt; processConfigurationClass()</span><br><span class="line">        - 2.this.deferredImportSelectorHandler.process() 处理入口</span><br><span class="line">            - ConfigurationClassParser.DeferredImportSelectorHandler.process()</span><br><span class="line">            - 1.创建 DeferredImportSelectorGroupingHandler</span><br><span class="line">            - 2.deferredImports排序</span><br><span class="line">            - 3.deferredImports注册</span><br><span class="line">            - 4.handler.processGroupImports(); &#x2F;&#x2F; 处理</span><br><span class="line">                - ConfigurationClassParser.DeferredImportSelectorGroupingHandler#processGroupImports()</span><br><span class="line">                - 1.遍历groupings.values(),调用grouping.getImports()</span><br><span class="line">                    - ConfigurationClassParser.DeferredImportSelectorGrouping#getImports()</span><br><span class="line">                    - 1.this.group.process()</span><br><span class="line">                        - AutoConfigurationImportSelector.AutoConfigurationGroup#process()</span><br><span class="line">                        - 1.getAutoConfigurationEntry(getAutoConfigurationMetadata(),annotationMetadata)</span><br><span class="line">                            - AutoConfigurationImportSelector#getAutoConfigurationEntry() </span><br><span class="line">                            - 1.isEnabled(annotationMetadata)判断ENABLED_OVERRIDE_PROPERTY属性,是否启用自动配置</span><br><span class="line">                            - 2.getCandidateConfigurations(): 通过 spi 加载 spring.factories 里所有的 AutoConfiguration 配置类</span><br><span class="line">                            - 3.removeDuplicates() 移除重复配置</span><br><span class="line">                            - 4.getExclusions(): exclusions处理</span><br><span class="line">                            - 5.filter(): 遍历AutoConfigurationImportFilter类,做filter处理</span><br><span class="line">                            - 6.fireAutoConfigurationImportEvents(): 发布AutoConfigurationImportEvent事件</span><br><span class="line">                    - 2.this.group.selectImports()</span><br><span class="line">                        - AutoConfigurationImportSelector.AutoConfigurationGroup#selectImports() 做排序并返回</span><br><span class="line">                - 2.processImports()</span><br><span class="line">                    - ConfigurationClassParser#processImports():就是ConfigurationClassParser里类对@Import注解的处理逻辑</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spring-boot-EnableAutoConfiguration&quot;&gt;&lt;a href=&quot;#spring-boot-EnableAutoConfiguration&quot; class=&quot;headerlink&quot; title=&quot;spring-boot EnableAuto
      
    
    </summary>
    
      <category term="spring-boot" scheme="http://yoursite.com/categories/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="http://yoursite.com/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring ConfigurationClassParser</title>
    <link href="http://yoursite.com/2020/06/13/01no/spring/spring10-ConfigurationClassParser/"/>
    <id>http://yoursite.com/2020/06/13/01no/spring/spring10-ConfigurationClassParser/</id>
    <published>2020-06-12T16:00:00.000Z</published>
    <updated>2020-06-14T03:52:28.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-ConfigurationClassParser"><a href="#Spring-ConfigurationClassParser" class="headerlink" title="Spring ConfigurationClassParser"></a>Spring ConfigurationClassParser</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- ConfigurationClassPostProcessor.processConfigBeanDefinitions()</span><br><span class="line">- 1.获取 registry 中的 beanDefinitionNames</span><br><span class="line">- 2.遍历beanDefinitionNames判断beanDefinition 是否是 @Configuration 配置类,若是则添加到 configCandidates 集合中</span><br><span class="line">- 3.configCandidates根据Order排序</span><br><span class="line">- 4.创建ConfigurationClassParser,配置类解析器</span><br><span class="line">- 5.遍历configCandidates,调用parser.parse()进行配置类解析</span><br><span class="line">    - ConfigurationClassParser.parse()</span><br><span class="line">    - 1.遍历configCandidates,获取当前的beanDefinition</span><br><span class="line">    - 2.根据不同类型的beanDefinition,调用不同入参的parse()方法</span><br><span class="line">        - ConfigurationClassParser.processConfigurationClass()</span><br><span class="line">        - 1.是否需要跳过 @Conditional</span><br><span class="line">        - 2.循环递归调用doProcessConfigurationClass()方法,处理配置类和父类,直到没有父类时,方法返回null,结束循环</span><br><span class="line">            - ConfigurationClassParser.doProcessConfigurationClass()</span><br><span class="line">            - 1.判断是否含有 @Component 注解,首先递归处理任何成员(嵌套)类</span><br><span class="line">            - 2.若有PropertySources注解,循环处理 @PropertySource 注解</span><br><span class="line">            - 3.若有@ComponentScan注解,处理 @ComponentScan 注解</span><br><span class="line">            - 4.处理 @Import 注解</span><br><span class="line">            - 5.若有 @ImportResource 注解,处理 @ImportResource 注解</span><br><span class="line">            - 6.处理 @Bean 注解的方法</span><br><span class="line">            - 7.如果有父类,获取父类名,外层循环会继续调用该方法解析父类.没有父类返回null,结束循环</span><br><span class="line">- 6.loadBeanDefinitions() 把前面解析出来的对象注册到容器中</span><br></pre></td></tr></table></figure><h2 id="ConfigurationClassParser-doProcessConfigurationClass"><a href="#ConfigurationClassParser-doProcessConfigurationClass" class="headerlink" title="ConfigurationClassParser.doProcessConfigurationClass()"></a>ConfigurationClassParser.doProcessConfigurationClass()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 通过解析源类中的 注解、成员 和 方法,创建 ConfigurationClass</span></span><br><span class="line"><span class="comment">    * Apply processing and build a complete &#123;<span class="doctag">@link</span> ConfigurationClass&#125; by reading the</span></span><br><span class="line"><span class="comment">    * annotations, members and methods from the source class. This method can be called</span></span><br><span class="line"><span class="comment">    * multiple times as relevant sources are discovered.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> configClass the configuration class being build</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> sourceClass a source class</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the superclass, or &#123;<span class="doctag">@code</span> null&#125; if none found or previously processed</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123; <span class="comment">// 含有 @Component 注解</span></span><br><span class="line">        <span class="comment">// Recursively process any member (nested) classes first.首先递归处理任何成员(嵌套)类</span></span><br><span class="line">        processMemberClasses(configClass, sourceClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any @PropertySource annotations. 处理 @PropertySource</span></span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">            sourceClass.getMetadata(), PropertySources<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">            <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">context</span>.<span class="title">annotation</span>.<span class="title">PropertySource</span>.<span class="title">class</span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">            processPropertySource(propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(<span class="string">"Ignoring @PropertySource annotation on ["</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">                    <span class="string">"]. Reason: Environment must implement ConfigurableEnvironment"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any @ComponentScan annotations. 处理 @ComponentScan 注解</span></span><br><span class="line">    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">            sourceClass.getMetadata(), ComponentScans<span class="class">.<span class="keyword">class</span>, <span class="title">ComponentScan</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">            !<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">            <span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">                    <span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">            <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                <span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bdCand = holder.getBeanDefinition();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123; <span class="comment">// 判断解析获取的 BeanDefinition 中 是否有配置类.也就是说只要有 @Configuration、@Component、@ComponentScan、@Import、@ImportResource 和 @Bean 中的其中一个注解</span></span><br><span class="line">                    parse(bdCand.getBeanClassName(), holder.getBeanName()); <span class="comment">// 如果有配置类,递归调用,解析该配置类</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any @Import annotations. 处理 @Import 注解</span></span><br><span class="line">    processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any @ImportResource annotations. 处理 @ImportResource 注解</span></span><br><span class="line">    AnnotationAttributes importResource =</span><br><span class="line">            AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (importResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] resources = importResource.getStringArray(<span class="string">"locations"</span>);</span><br><span class="line">        Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">"reader"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">            String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">            configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process individual @Bean methods. 处理 @Bean 方法</span></span><br><span class="line">    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass); <span class="comment">// 检索 @Bean 方法</span></span><br><span class="line">    <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">        configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass)); <span class="comment">// 创建 BeanMethod,添加到 beanMethods</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process default methods on interfaces</span></span><br><span class="line">    processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process superclass, if any. 如果有父类,则解析父类</span></span><br><span class="line">    <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">        String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">        <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="string">"java"</span>) &amp;&amp;</span><br><span class="line">                !<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">            <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">            <span class="keyword">return</span> sourceClass.getSuperClass(); <span class="comment">// 不返回null,外层循环调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 循环出口.没有父类,处理完成,返回null,外层结束循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-ConfigurationClassParser&quot;&gt;&lt;a href=&quot;#Spring-ConfigurationClassParser&quot; class=&quot;headerlink&quot; title=&quot;Spring ConfigurationClassParse
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring component-scan实现</title>
    <link href="http://yoursite.com/2020/06/06/01no/spring/spring11-component-scan/"/>
    <id>http://yoursite.com/2020/06/06/01no/spring/spring11-component-scan/</id>
    <published>2020-06-05T16:00:00.000Z</published>
    <updated>2020-06-07T05:56:23.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="componet-scan"><a href="#componet-scan" class="headerlink" title="componet-scan"></a>componet-scan</h1><p>分为 xml 配置 和 注解配置两种方式,二者入口不同,实现上没太多差别.<br>都是先解析配置,根据配置的 basePackages 用asm扫描<code>.class</code>上是否有@Component注解,若有则生成beanName,注册到容器里即可.</p><h2 id="context-component-scan-实现"><a href="#context-component-scan-实现" class="headerlink" title="context:component-scan/实现"></a><a href="context:component-scan/">context:component-scan/</a>实现</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.zc"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a>切入点</h3><p>对于自定义标签的解析入口在 <code>DefaultBeanDefinitionDocumentReader.parseCustomElement(ele);</code> 里.<br>1.先根据标签获取parser,这里是 <code>ComponentScanBeanDefinitionParser</code><br><img src="https://gitee.com/flyingzc/MyImg/raw/master/img/20200606180506.png" alt="根据标签获取parser"></p><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- NamespaceHandlerSupport.parse(): 根据元素获取parser进行处理,这里使用的是ComponentScanBeanDefinitionParser</span><br><span class="line">    - ComponentScanBeanDefinitionParser.parse()</span><br><span class="line">    - 1.configureScanner()</span><br><span class="line">        - ComponentScanBeanDefinitionParser.createScanner()</span><br><span class="line">        - 1.createScanner(): 将 beanDefinition注册 委托给 Scanner 类</span><br><span class="line">            - ClassPathScanningCandidateComponentProvider()构造方法</span><br><span class="line">            - 1.registerDefaultFilters(): 支持Component注解,创建AnnotationTypeFilter,加入includeFilters里</span><br><span class="line">        - 2.parseBeanNameGenerator(): 生成beanName</span><br><span class="line">        - 3.parseScope(): 解析 scoped-proxy 和 scope-resolver 属性</span><br><span class="line">        - 4.parseTypeFilters(): 解析配置的类型过滤器属性,包括 include-filter 和 exclude-filter</span><br><span class="line">    - 2.scanner.doScan(basePackages)</span><br><span class="line">        - ComponentScanBeanDefinitionParser.doScan()</span><br><span class="line">        - 1.遍历所有basePackage</span><br><span class="line">        - 2.findCandidateComponents(basePackage): 扫描 basePackage 下的 bean definition</span><br><span class="line">            - ClassPathScanningCandidateComponentProvider.findCandidateComponents()</span><br><span class="line">            - 1.根据 basePackage 从 classpath*:com&#x2F;zc&#x2F;**&#x2F;*.class 中 扫描所有符合条件的 .class</span><br><span class="line">            - 2.遍历符合条件的.class,用asm判断上面是否有 @Component 注解</span><br><span class="line">        - 3.遍历 上一步扫出来的@Component注解的beanDefinitions,生成beanName</span><br><span class="line">            - AnnotationBeanNameGenerator.generateBeanName()</span><br><span class="line">            - 1.determineBeanNameFromAnnotation(): 若注解上配了value值,作为beanName</span><br><span class="line">            - 2.若没配置,则buildDefaultBeanName()获取类名转成对象名,返回默认的beanName</span><br><span class="line">        - 4.若beanDefinition没注册,调用registerBeanDefinition()注册beanDefinition</span><br></pre></td></tr></table></figure><h2 id="ComponentScan-注解实现"><a href="#ComponentScan-注解实现" class="headerlink" title="@ComponentScan 注解实现"></a>@ComponentScan 注解实现</h2><p>入口再 ComponentScanAnnotationParser 里,实现上和上面差不多.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;componet-scan&quot;&gt;&lt;a href=&quot;#componet-scan&quot; class=&quot;headerlink&quot; title=&quot;componet-scan&quot;&gt;&lt;/a&gt;componet-scan&lt;/h1&gt;&lt;p&gt;分为 xml 配置 和 注解配置两种方式,二者入口不
      
    
    </summary>
    
      <category term="spring" scheme="http://yoursite.com/categories/spring/"/>
    
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot启动流程</title>
    <link href="http://yoursite.com/2020/05/24/01no/springboot/springboot02-start/"/>
    <id>http://yoursite.com/2020/05/24/01no/springboot/springboot02-start/</id>
    <published>2020-05-23T16:00:00.000Z</published>
    <updated>2020-05-24T09:42:20.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-boot-启动"><a href="#spring-boot-启动" class="headerlink" title="spring-boot 启动"></a>spring-boot 启动</h1><ul><li>spingboot-start<ul><li>SpringApplication构造方法<ul><li>使用 SpringFactoriesLoader 在 classpath 中查找并加载所有可用的 ApplicationContextInitializer</li><li>使用 SpringFactoriesLoader 在 classpath 中查找并加载所有可用的 ApplicationListener</li><li>通过stackTrace里的main方法查找启动类</li></ul></li><li>SpringApplication.run()<ul><li>创建StopWatch计时器</li><li>通过 SpringFactoriesLoader 查找并加载 SpringApplicationRunListener 列表,调用 SpringApplicationRunListener.started() 方法</li><li>创建Environment<ul><li>configureEnvironment()</li><li>listeners.environmentPrepared(): 广播 ApplicationEnvironmentPreparedEvent 事件</li></ul></li><li>打印banner</li><li>createApplicationContext(): 创建applicationContext</li><li>prepareContext()<ul><li>context.setEnvironment()</li><li>postProcessApplicationContext()</li><li>applyInitializers():调用 initializers.initialize()</li><li>listeners.contextPrepared():广播 ApplicationContextInitializedEvent</li><li>load():加载 beanDefinitions</li><li>listeners.contextLoaded()<ul><li>1.若listener实现了 ApplicationContextAware 接口,调用 setApplicationContext()</li><li>2.广播ApplicationPreparedEvent事件</li></ul></li></ul></li><li>refreshContext():调用 spring 的 refresh()方法<ul><li>AbstractApplicationContext.refresh()逻辑</li></ul></li><li>afterRefresh():钩子,目前 do nothing</li><li>广播 ApplicationStartedEvent 事件</li><li>callRunners()<ul><li>调用ApplicationRunner和CommandLineRunner类型对象的run()方法</li></ul></li><li>若上面执行有异常,则handleRunFailure()</li><li>listeners.running():广播ApplicationReadyEvent事件</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spring-boot-启动&quot;&gt;&lt;a href=&quot;#spring-boot-启动&quot; class=&quot;headerlink&quot; title=&quot;spring-boot 启动&quot;&gt;&lt;/a&gt;spring-boot 启动&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;spingboot-start&lt;
      
    
    </summary>
    
      <category term="spring-boot" scheme="http://yoursite.com/categories/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="http://yoursite.com/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>idea搭建spring-boot环境</title>
    <link href="http://yoursite.com/2020/05/19/01no/springboot/springboot01-build/"/>
    <id>http://yoursite.com/2020/05/19/01no/springboot/springboot01-build/</id>
    <published>2020-05-18T16:00:00.000Z</published>
    <updated>2020-05-24T11:17:45.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="idea搭建spring-boot环境"><a href="#idea搭建spring-boot环境" class="headerlink" title="idea搭建spring-boot环境"></a>idea搭建spring-boot环境</h1><h2 id="显示tag"><a href="#显示tag" class="headerlink" title="显示tag"></a>显示tag</h2><p>git tag</p><p>选择 v2.1.5.RELEASE 版本,这是我们项目里现在在用的版本,还比较新,最新的目前是 2.3.0.</p><h2 id="拉自己的分支"><a href="#拉自己的分支" class="headerlink" title="拉自己的分支"></a>拉自己的分支</h2><ol><li><p>建立我自己的分支,以后代码注释都写在这个分支上.<code>v2.1.5.RELEASE-zc</code></p><p> git checkout -b v2.1.5.RELEASE-zc v2.1.5.RELEASE</p><p> v2.1.5.RELEASE 这个版本是可以选择 maven 或 gradle 构建的,我这里选的maven.</p><p> 工程依赖的jar包很多,大概要下个半小时多.</p></li><li><p>将本地分支推到远程<br>git push origin v2.1.5.RELEASE-zc</p></li><li><p>建立关联<br>git push –set-upstream origin v2.1.5.RELEASE-zc</p></li></ol><h2 id="看看代码量"><a href="#看看代码量" class="headerlink" title="看看代码量"></a>看看代码量</h2><p>spring-boot 总共代码45w行,纯代码 27w 行.<br><img src="https://gitee.com/flyingzc/MyImg/raw/master/img/2020-05-19-22-15-54.png" alt="代码量统计"></p><h2 id="idea-attach-source"><a href="#idea-attach-source" class="headerlink" title="idea attach source"></a>idea attach source</h2><p>idea 的配置最终都落到 .idea 下的 xml 里,搜索 springboot 的 maven 配置文件,修改里面的 sources.<br>Maven__org_springframework_boot_spring_boot_2_1_5_RELEASE.xml</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;idea搭建spring-boot环境&quot;&gt;&lt;a href=&quot;#idea搭建spring-boot环境&quot; class=&quot;headerlink&quot; title=&quot;idea搭建spring-boot环境&quot;&gt;&lt;/a&gt;idea搭建spring-boot环境&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="spring-boot" scheme="http://yoursite.com/categories/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="http://yoursite.com/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat处理请求流程</title>
    <link href="http://yoursite.com/2019/12/26/01no/tomcat/tomcat06-request/"/>
    <id>http://yoursite.com/2019/12/26/01no/tomcat/tomcat06-request/</id>
    <published>2019-12-25T16:00:00.000Z</published>
    <updated>2020-05-24T11:30:52.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tomcat处理请求"><a href="#tomcat处理请求" class="headerlink" title="tomcat处理请求"></a>tomcat处理请求</h1><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Server</span><br><span class="line">|-- Service</span><br><span class="line">|--|-- Connector</span><br><span class="line">|--|--|-- Prototal</span><br><span class="line">|--|--|--|-- Endpoint</span><br><span class="line">|--|--|--|--|-- Acceptor</span><br><span class="line">|--|--|--|--|-- Executor</span><br><span class="line">|--|--|--|-- Processor</span><br><span class="line">|--|--|-- Mapper</span><br><span class="line">|--|--|-- CoyteAdapter</span><br><span class="line">|--|-- Container</span><br><span class="line">|--|--|--|-- Host</span><br><span class="line">|--|--|--|-- Context</span><br><span class="line">|--|--|--|-- Wrapper</span><br><span class="line">|--|-- Executor</span><br></pre></td></tr></table></figure><h3 id="Http11NioProtocol"><a href="#Http11NioProtocol" class="headerlink" title="Http11NioProtocol"></a>Http11NioProtocol</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Http11NioProtocol</span><br><span class="line">|-- NioEndpoint</span><br><span class="line">|--|-- LimitLatch</span><br><span class="line">|--|-- Acceptor</span><br><span class="line">|--|-- Poller</span><br><span class="line">|--|-- Poller池</span><br><span class="line">|--|-- SocketProcessor</span><br><span class="line">|--|-- Executor</span><br><span class="line">|--|-- PollerEvent</span><br><span class="line">|--|-- KeyAttachment</span><br><span class="line">|--|-- NioBufferHandler</span><br><span class="line">|-- Http11ConnectionHandler</span><br><span class="line">|-- Http11NioProcessor</span><br></pre></td></tr></table></figure><h3 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h3><p>接收客户端连接并响应</p><h3 id="Protocol协议"><a href="#Protocol协议" class="headerlink" title="Protocol协议"></a>Protocol协议</h3><p>协议的抽象.<br>Protocol分类: Http11Protocol,Http11NioProtocol 等.</p><h3 id="Http11NioProtocol-1"><a href="#Http11NioProtocol-1" class="headerlink" title="Http11NioProtocol"></a>Http11NioProtocol</h3><p>包含 NioEndpoint 和 Http11NioProcessor</p><h3 id="NioEndpoint"><a href="#NioEndpoint" class="headerlink" title="NioEndpoint"></a>NioEndpoint</h3><h3 id="LimitLatch"><a href="#LimitLatch" class="headerlink" title="LimitLatch"></a>LimitLatch</h3><p>连接数控制,nio模式下默认是10000,达到这个阈值后,就会拒绝连接请求.使用AQS实现的一个共享锁.</p><h4 id="LimitLatch相关流程"><a href="#LimitLatch相关流程" class="headerlink" title="LimitLatch相关流程"></a>LimitLatch相关流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- 初始化最大连接数量</span><br><span class="line">    - endpoint.startInternal()</span><br><span class="line">        -  initializeConnectionLatch(); 初始化LimitLatch,用于控制连接的数量  </span><br><span class="line">            - connectionLimitLatch &#x3D; new LimitLatch(getMaxConnections()); 根据最大的连接数量来创建  </span><br><span class="line"></span><br><span class="line">- acceptor接收请求前,连接计数+1.若到达最大值则等待其他连接释放</span><br><span class="line">    - acceptor.run()</span><br><span class="line">        - countUpOrAwaitConnection();&#x2F;&#x2F; 增加连接计数,若connection数量已经达到了最大等待 socket &#x3D; serverSocket.accept();  然后再等待连接,若上一步阻塞则不会到此处</span><br><span class="line"></span><br><span class="line">- 连接计数-1</span><br><span class="line">    - (!setSocketOptions(socket)) &#123;  &#x2F;&#x2F;这里主要是将socket加入到poller对象上面去,而且还要设置参数     </span><br><span class="line">        countDownConnection();  &#x2F;&#x2F; 加入poller对象失败了的话,那么将LimitLatch的计数减1 </span><br><span class="line">      &#125;</span><br><span class="line">    - endpoint.cancelKey()</span><br><span class="line">        - countDownConnection();</span><br></pre></td></tr></table></figure><h3 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h3><p>接收socket连接<br>通过 serverSocket.accept() 获得 SocketChannel 对象,封装成 org.apache.tomcat.util.net.NioChannel.<br>再将 NioChannel 封装成 PollerEvent, 并将 PollerEvent 压入 events queue里,即<code>ConcurrentLinkedQueue&lt;PollerEvent&gt; events</code>里.</p><h3 id="Poller-轮询器"><a href="#Poller-轮询器" class="headerlink" title="Poller 轮询器"></a>Poller 轮询器</h3><p>轮询 events.由 Poller 将就绪的事件 生成 SocketProcessor,交由 Executor 处理.</p><h3 id="Poller池"><a href="#Poller池" class="headerlink" title="Poller池"></a>Poller池</h3><p>包含若干 Poller 组件</p><h3 id="SocketProcessor"><a href="#SocketProcessor" class="headerlink" title="SocketProcessor"></a>SocketProcessor</h3><p>具体的 http 请求头等解析操作全是 Http11NioProcessor 处理的, 但是是在 NioEndpoint.SocketProcessor 线程的run()方法里调用的.</p><ul><li>结构(属性)<ul><li>NioChannel socket</li><li>SocketStatus status</li></ul></li></ul><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>Executor 拿到 Poller 传过来的 socket 后,将 socket 封装在 SocketProcessor 对象中.<br>然后从 Http11ConnectionHandler 中取出 Http11NioProcessor 对象.</p><h3 id="PollerEvent"><a href="#PollerEvent" class="headerlink" title="PollerEvent"></a>PollerEvent</h3><p>对 NioChannel 的包装,用于注册到 Poller.event 队列中.</p><ul><li>属性<ul><li>NioChannel socket<ul><li>NioChannel是 非阻塞通道.负责将数据读到缓冲区中,或将数据从缓冲区中写入.</li></ul></li><li>int interestOps; // 感兴趣的事件,第一次是OP_REGISTER</li><li>KeyAttachment key;// KeyAttachment包装nioChannel</li></ul></li></ul><h3 id="KeyAttachment"><a href="#KeyAttachment" class="headerlink" title="KeyAttachment"></a>KeyAttachment</h3><ul><li>注册到SelectionKey上的附件,对 NioChannel 的包装类.</li></ul><h3 id="NioBufferHandler"><a href="#NioBufferHandler" class="headerlink" title="NioBufferHandler"></a>NioBufferHandler</h3><ul><li>分配nio的buffer的读写空间,内部包含ByteBuffer类型的readbuf和writebuf属性.在构建NioChannel时使用.</li></ul><h3 id="Http11ConnectionHandler"><a href="#Http11ConnectionHandler" class="headerlink" title="Http11ConnectionHandler"></a>Http11ConnectionHandler</h3><ul><li>结构(属性)<ul><li><code>protected final Map&lt;S,Processor&lt;S&gt;&gt; connections = new ConcurrentHashMap&lt;S,Processor&lt;S&gt;&gt;();</code><br>connections 这个 Map维护NioChannel(内部包含socket通道)与processor的关系(如Http11NioProcessor).<br>所以若processor一次不能读取到 所需的所有数据,就等下一次poller轮询时根据socket找到这个processor继续读取.</li></ul></li></ul><h3 id="Http11NioProcessor"><a href="#Http11NioProcessor" class="headerlink" title="Http11NioProcessor"></a>Http11NioProcessor</h3><p>nio方式解析请求头等.</p><ul><li>结构<ul><li>InternalNioInputBuffer</li><li>InternalNioOutputBuffer</li></ul></li></ul><h3 id="Nio涉及的其他类"><a href="#Nio涉及的其他类" class="headerlink" title="Nio涉及的其他类"></a>Nio涉及的其他类</h3><ul><li>NioChannel<ul><li>作用<ul><li>NioChannel是 非阻塞通道.负责将数据读到缓冲区中,或将数据从缓冲区中写入.</li></ul></li><li>结构<ul><li>Nio.SocketChannel</li><li>NioEndpoint.NioBufferHandler</li></ul></li></ul></li><li>SocketProperties<ul><li>从server.xml的Connector节点上获取参数值,设置nio的socket属性</li></ul></li></ul><h3 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h3><ul><li>路由</li></ul><h3 id="CoyoteAdapter"><a href="#CoyoteAdapter" class="headerlink" title="CoyoteAdapter"></a>CoyoteAdapter</h3><ul><li>将Connector和Engine适配起来.</li></ul><h3 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h3><h4 id="1-Acceptor线程"><a href="#1-Acceptor线程" class="headerlink" title="1. Acceptor线程"></a>1. Acceptor线程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- 1.Acceptor线程操作 NioEndpoint中 acceptor.run()</span><br><span class="line">- 该acceptor线程一直循环,直到接收到关闭命令</span><br><span class="line">- countUpOrAwaitConnection(); 通过 LimitLatch 增加连接计数,若已经到达 最大连接数,则让该acceptor线程等待(直到其他线程释放连接),相当于拒绝掉客户端请求</span><br><span class="line">- socket &#x3D; serverSock.accept(); 接收新连接,返回SocketChannel客户端连接对象,这里用的是阻塞模式. 整个循环靠此处阻塞,直到接收到客户端请求才继续往下走</span><br><span class="line">- setSocketOptions(socket) 设置socket属性,这里面主要 将socketChannel包装到nioChannel里. 再将nioChannel包装到PollerEvent里,并放入轮询的事件队列events中</span><br><span class="line">    - socket.configureBlocking(false); 将socket连接通道设置为非阻塞模式</span><br><span class="line">    - Socket sock &#x3D; socket.socket(); 从nio.SocketChannel中获取java.net.Socket</span><br><span class="line">    - socketProperties.setProperties(sock); 设置socket的参数值(从server.xml的Connector节点上获取参数值), 如 socket发送,接收的大小.心跳检测,超时时长等</span><br><span class="line">    - NioChannel channel &#x3D; nioChannels.poll(); 构造NioChannel对象,从ConcurrentLinkedQueue (即NioChannel的缓存队列) 中取</span><br><span class="line">        - 附:ConcurrentLinkedQueue&lt;NioChannel&gt;类型的nioChannels对象的作用 将关闭通道的nioChannel放入Queue缓存起来,方便复用.复用时替换掉其内部的SocketChannel对象即可, NioChannel包含的其他属性只需做重置操作即可.当获取不到时再重新创建</span><br><span class="line">        - 取不到则新创建 channel &#x3D; new NioChannel(socket, bufhandler); 将socketChannel对象 封装到NioChannel对象中.非SSL的.  </span><br><span class="line">        1.socket参数: 进行读写操作的nio.SocketChannel对象.  </span><br><span class="line">        2.bufhandler参数: 为NioChannel.NioBufferHandler.这个类用于 根据xml配置 分配nio的buffer的读写空间. 是对nio.Buffer的封装. 提供用于操作 待写入SocketChannel缓存区 和  读取SocketChannel的缓冲区的方法.</span><br><span class="line">    - getPoller0().register(channel); 将新接收到的SocketChannel注册到event队列上 (将nioChannel包装成PollerEvent 注册到轮询线程events上)</span><br><span class="line">        - getPoller0() 轮询当前的Poller线程数组,从中取出一个Poller并返回</span><br><span class="line">        - Poller.register() 将新接收到的SocketChannel注册到event队列上(nioChannel包装成PollerEvent 注册到轮询线程) </span><br><span class="line">            1.创建KeyAttachment并与poller关联;  2.将channelSocket(nioChannel)包装成PollerEvent 注册到事件队列(events)中;  3.是否需要对selector wakeup的处理</span><br><span class="line">            - new KeyAttachment(socket) 创建或从缓存中取出KeyAttachment并重置. KeyAttachment是对NioChannel的一层包装</span><br><span class="line">            - ka.reset(this,socket,getSocketProperties().getSoTimeout()); 重置KeyAttachment对象中Poller,NioChannel等成员变量的引用</span><br><span class="line">            - ka.interestOps(SelectionKey.OP_READ); 设置keyAttachement 读操作(SelectionKey.OP_READ) 为感兴趣的操作</span><br><span class="line">            - PollerEvent r &#x3D; eventCache.poll(); 从通道缓存队列中取出一个PollerEvent. 取到则重置属性,取不到则新建</span><br><span class="line">                - 取不到则新建 r &#x3D; new PollerEvent(socket,ka,OP_REGISTER); 若取出为空,则新建.将nioChannel包装到PollerEvent对象中. 否则,重置PollerEvent中的属性. 并注册一个OP_REGISTER(对应)928行pollerEvent.run()里</span><br><span class="line">            - poller.addEvent(r); 将PollerEvent添加到轮询队列(poller.events)中. 相当于每个poller都维护了一个event队列,代表这个poller需要处理的事件列表</span><br><span class="line">                - events.offer(event); 将event添加到events队列中</span><br><span class="line">                - if ( wakeupCounter.incrementAndGet() &#x3D;&#x3D; 0 ) selector.wakeup(); </span><br><span class="line">                    使一个还未返回的 select() 方法立即返回.即若当前事件队列中 没有事件,则唤醒处于阻塞在selector.select()状态上的线程(会唤醒selector).与1208行对应</span><br><span class="line">                    - 附:Poller类中protected AtomicLong wakeupCounter &#x3D; new AtomicLong(0l);的作用 唤醒 多路复用器(即nio中的selector)的条件阈值.</span><br><span class="line">                    作用: 1.告诉Poller当前有多少个新连接,这样当Poller进行selector的操作时,可以选择是否需要阻塞来等待读写请求到达; </span><br><span class="line">                    2.标识Poller在进行select选择时,是否有连接到达.如果有,就让当前的阻塞调用立即返回</span><br></pre></td></tr></table></figure><h4 id="2-Poller线程"><a href="#2-Poller线程" class="headerlink" title="2. Poller线程"></a>2. Poller线程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- 2.Poller线程操作 poller.run()</span><br><span class="line">- poller.events() 从events队列中取出pollerEvent对象并run(); 即处理轮询器的事件队列中的事件,若事件队列是空的则返回false,否则返回true. 每个poller都有一个events队列,poller会一直循环取出里面的event进行处理</span><br><span class="line">    - while ( (r &#x3D; events.poll()) !&#x3D; null ) 循环从events队列 中 逐个取出PollerEvent事件,运行每一个PollerEvent的处理逻辑</span><br><span class="line">    - r.run(); 运行每一个PollerEvent的处理逻辑.即PollerEvent.run(). 注意,此处还是在当前线程中完成.因为调用的是r.run()不是r.start(), 可以理解成只是一个普通方法,在当前而不是新起一个线程</span><br><span class="line">        - PollerEvent.run() 若这个pollerEvent中的interestOps是OP_REGISTER, 则将pollerEvent.nioChannel.socketChannel注册到poller.selector上</span><br><span class="line">            - if ( interestOps &#x3D;&#x3D; OP_REGISTER ) </span><br><span class="line">            &#x2F;&#x2F; PollerEvent最初的interestOps就是OP_REGISTER socket.getIOChannel().register(socket.getPoller().getSelector(), SelectionKey.OP_READ, key); </span><br><span class="line">            从nioChannel中获取socketChannel,从poller中获取selector. 则此时将socketChannel.register(selector, OP_READ, keyAttachment),即将socketChannel向selector注册读感兴趣事件.  </span><br><span class="line">    - 上一步r.run()执行完后 ((PollerEvent)r).reset(); eventCache.offer((PollerEvent)r); 只要从events中取出后,便重置PollerEvent并缓存到eventCache中, 方便复用PollerEvent对象</span><br><span class="line">- Iterator&lt;SelectionKey&gt; iterator &#x3D; keyCount &gt; 0 ? selector.selectedKeys().iterator() : null; 根据向selector中注册的key遍历channel中已经就绪的SelectionKey,并处理这些key</span><br><span class="line">    - iterator遍历 SelectionKey sk &#x3D; iterator.next(); KeyAttachment attachment &#x3D; (KeyAttachment)sk.attachment(); 这里的attachment()返回的就是在register()中注册的KeyAttachement,该对象是对socket的包装类  attachment.access();更新 通道最近一次发生事件的事件,防止因超时没有事件发生而被剔除出selector iterator.remove();从迭代器中移除掉(因为下一步processKey就处理它)</span><br><span class="line">    - processKey(sk, attachment); 具体处理通道的逻辑,交由SocketProcessor处理 sk为SelectionKey</span><br><span class="line">        - NioChannel channel &#x3D; attachment.getChannel(); 从keyAttachment中获取nioChannel</span><br><span class="line">        - if (sk.isReadable() || sk.isWritable() ) &#123; SelectionKey处理通道(channel)发生的 读写事件 &#125;</span><br><span class="line">            - unreg(sk, attachment, sk.readyOps()); 在通道上 注销 对已经发生事件的关注, 防止通道对同一个事件不断select的问题</span><br><span class="line">            - 若sk.isReadable() 通道读事件的处理</span><br><span class="line">                - processSocket(channel, SocketStatus.OPEN_READ, true) 把SocketProcessor交给Excutor去执行.</span><br><span class="line">                    - 创建SocketProcessor实例 SocketProcessor sc &#x3D; processorCache.poll(); 从SocketProcessor缓存队列中取出一个来处理socket, 没有则新建.</span><br><span class="line">                    有则重置属性 new SocketProcessor(socket,status) socketProcessor内的socket属性为NioChannel类型</span><br><span class="line">                    - getExecutor().execute(sc); 将socketProccessor任务交由org.apache.tomcat.util.threads.ThreadPoolExecutor线程池处理, 则该线程池会调用socketProcessor.run() .</span><br><span class="line">                    即SocketProcessor实例是对NioChannel的封装.由Executor执行socketProcessor.run()方法</span><br></pre></td></tr></table></figure><h4 id="3-SocketProcessor线程"><a href="#3-SocketProcessor线程" class="headerlink" title="3. SocketProcessor线程"></a>3. SocketProcessor线程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- 3.SocketProcessor线程操作 socketProcessor.run()</span><br><span class="line">- socketProcessor.run()总体逻辑 1.使用nio方式 读取套接字 并进行处理, 输出响应报文;2.连接计数器减1,腾出通道;3.关闭套接字</span><br><span class="line">- SelectionKey key &#x3D; socket.getIOChannel().keyFor(socket.getPoller().getSelector()); 从socket(SocketProcessor的成员变量NioChannel类型)中获取SelectionKey</span><br><span class="line">- ka &#x3D; (KeyAttachment)key.attachment(); 从SelectionKey中获取关联的keyAttachment</span><br><span class="line">- synchronized (socket) &#123;&#x2F;&#x2F; 对NioChannel加锁     doRun(selectionkey, keyAttachment); &#125;  socketProcessor的具体逻辑</span><br><span class="line">    - state &#x3D; handler.process(ka, status); 此处handler为Http11NioProtocol$Http11ConnectionHandler, 这个静态类虽然在Http11NioProtocol内部,但是它持有Http11NioProtocol对象</span><br><span class="line">        - 调用父类AbstractProtocol.AbstractConnectionHandler.process() 该内部类的主要逻辑是获取HttpProcessor,缓存取 或新建</span><br><span class="line">            - state &#x3D; processor.process(wrapper); 使用Http11NioProcessor处理socket请求. 此处processor为Http11NioProcessor对象</span><br><span class="line">                - 父类AbstractHttp11Processor.process() 其实后面操作全是Http11NioProcessor处理了, 但是是在Endpoint.SocketProcessor线程的run()方法里调用的</span><br><span class="line">                    - getInputBuffer().init(socketWrapper, endpoint); 初始化 输入流.将socket的输入流 赋值给InterInputBuffer的inputStream属性</span><br><span class="line">                        - InternalNioInputBuffer.init() 设置internalNioInputBuffer的成员变量.如socket,buf大小,SelectorPool</span><br><span class="line">                    - getOutputBuffer().init(socketWrapper, endpoint); 初始化 输出流</span><br><span class="line">                        - 设置selectorPool和socket</span><br><span class="line">                    - getInputBuffer().parseRequestLine(keptAlive))  解析请求行</span><br><span class="line">                        - 即InternalNioInputBuffer.parseRequestLine()</span><br><span class="line">                            - InternalNioInputBuffer.fill(true,false) 读取socket数据到buf字节数组中. timeout:是否有超时;  block:是否阻塞读</span><br><span class="line">                                - InternalNioInputBuffer.readSocket() </span><br><span class="line">                                    从socket中读取数据到buf字节数组中. 从底层socket读取数据.有阻塞式 和 非阻塞式 从 socket中读. </span><br><span class="line">                                    若采用nio,在处理http请求的requestLine和header时非阻塞.  </span><br><span class="line">                                    处理body时必须阻塞 (因为读取body部分的 代码一般是在servlet部分控制的即上层代码控制,已经超出tomcat控制范围). </span><br><span class="line">                                    - socket.getBufHandler().getReadBuffer().clear();  清空nio.ByteBuffer,方便下面将socket里读取的新数据写进去</span><br><span class="line">                                    - 由于block&#x3D;false,此处非阻塞读 即nRead &#x3D; socket.read(socket.getBufHandler().getReadBuffer());</span><br><span class="line">                                        - sc.read(dst); 其实就是socketChannel.read(buffer) &#x2F;&#x2F; read into buffer</span><br><span class="line">                                    - if (nRead &gt; 0) &#123;&#x2F;&#x2F; 若有数据读取出来     </span><br><span class="line">                                        socket.getBufHandler().getReadBuffer().flip();&#x2F;&#x2F; 调用ByteBuffer.flip()将buffer切换到读模式     </span><br><span class="line">                                        socket.getBufHandler().getReadBuffer().limit(nRead);&#x2F;&#x2F; 设置buffer.limit就是本次读取的长度     </span><br><span class="line">                                        expand(nRead + pos);&#x2F;&#x2F; 检查当前对象的buf字节数组容量是否够大,若不够则扩容     </span><br><span class="line">                                        socket.getBufHandler().getReadBuffer().get(buf, pos, nRead);&#x2F;&#x2F; 将socket读取的数据 转移到当前对象的buf数组中     </span><br><span class="line">                                        lastValid &#x3D; pos + nRead;&#x2F;&#x2F; 更新最后一个有效数据的下标     </span><br><span class="line">                                        return nRead; &#125;</span><br><span class="line">                    - getInputBuffer().parseHeaders() 解析请求头</span><br><span class="line">                    - adapter.service(request, response); 将socket封装成request,response,再交给adapter做后续处理</span><br><span class="line">                        - coyteAdapter.postParseRequest()</span><br><span class="line">                            - 匹配请求对应的Host,Context,Wrapper </span><br><span class="line">                            connector.getMapper().map(serverName, decodedURI, version, request.getMappingData()); </span><br><span class="line">                            request.setContext((Context) request.getMappingData().context); </span><br><span class="line">                            request.setWrapper((Wrapper) request.getMappingData().wrapper);</span><br><span class="line">                        - connector.getService().getContainer().getPipeline().getFirst().invoke(request, response); 调用container.调用StandardEngine的pipeline 处理request和response</span><br><span class="line">                            - StandardEngineValve.invoke()中 host.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">                                - AccessLogValve.invoke()中 getNext().invoke(request, response); 没做事,直接调下一个管道</span><br><span class="line">                                    - ErrorReportValve.invoke() tomcat错误输出页面</span><br><span class="line">                                        - StandardHostValve.invoke() context.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">                                            - AuthenticatorBase.invoke() getNext().invoke(request, response);</span><br><span class="line">                                                - StandardContextValve.invoke() wrapper.getPipeline().getFirst().invoke(request, response); 调用wrapper的pipeline来处理请求,即StandardWrapperValve</span><br><span class="line">                                                    - StandardWrapperValve.invoke() filterChain.doFilter(request.getRequest(), response.getResponse()); 调用fiterChain来处理 request 和 response</span><br><span class="line">                                                        - ApplicationFilterChain.doFilter()中 internalDoFilter(request,response);</span><br><span class="line">                                                            - filter.doFilter(request, response, this); 调用具体filter.doFilter方法</span><br><span class="line">                                                                - WsFilter.doFilter()</span><br><span class="line">                                                                    - ApplicationFilterChain.internalDoFilter()中 servlet.service(request, response); 调用对应servlet.service()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tomcat处理请求&quot;&gt;&lt;a href=&quot;#tomcat处理请求&quot; class=&quot;headerlink&quot; title=&quot;tomcat处理请求&quot;&gt;&lt;/a&gt;tomcat处理请求&lt;/h1&gt;&lt;h2 id=&quot;组件&quot;&gt;&lt;a href=&quot;#组件&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Tomcat" scheme="http://yoursite.com/categories/Tomcat/"/>
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat实现分布式session</title>
    <link href="http://yoursite.com/2019/12/20/01no/tomcat/tomcat04-distribute-session/"/>
    <id>http://yoursite.com/2019/12/20/01no/tomcat/tomcat04-distribute-session/</id>
    <published>2019-12-19T16:00:00.000Z</published>
    <updated>2020-05-24T11:45:26.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tomcat实现分布式session"><a href="#tomcat实现分布式session" class="headerlink" title="tomcat实现分布式session"></a>tomcat实现分布式session</h1><p>tomcat-redis-session-manager</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Copy the following files into the TOMCAT_BASE/lib directory:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tomcat-redis-session-manager-VERSION.jar</span><br><span class="line">jedis-2.5.2.jar</span><br><span class="line">commons-pool2-2.2.jar</span><br></pre></td></tr></table></figure><p>配置 TOMCAT_HOME/conf/context.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"com.radiadesign.catalina.session.RedisSessionHandlerValve"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"com.radiadesign.catalina.session.RedisSessionManager"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">host</span>=<span class="string">"localhost"</span>   </span></span><br><span class="line"><span class="tag">         <span class="attr">port</span>=<span class="string">"6379"</span> <span class="attr">database</span>=<span class="string">"0"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">maxInactiveInterval</span>=<span class="string">"30"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>mvn 里搜 Tomcat Redis Session Manager<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.bluejeans/tomcat-redis-session-manager --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bluejeans<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-redis-session-manager<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RedisSessionHandlerValve</span><br><span class="line"></span><br><span class="line">RedisSession</span><br><span class="line"></span><br><span class="line">RedisSessionManager</span><br><span class="line"></span><br><span class="line">JavaSerializer</span><br><span class="line"></span><br><span class="line">DeserializedSessionContainer</span><br><span class="line"></span><br><span class="line">Serializer</span><br><span class="line"></span><br><span class="line">SessionSerializationMetadata</span><br></pre></td></tr></table></figure><p>其中 RedisSessionHandlerValve 是在 context 层配置的 value.</p><p>RedisSessionManager 继承自 tomcat 的 ManagerBase,实现 Lifecycle 接口.</p><p>RedisSession 继承自 tomcat 的 StandardSession.</p><h2 id="RedisSessionHandlerValve-对-session-的处理"><a href="#RedisSessionHandlerValve-对-session-的处理" class="headerlink" title="RedisSessionHandlerValve 对 session 的处理"></a>RedisSessionHandlerValve 对 session 的处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- RedisSessionHandlerValve.invoke()</span><br><span class="line">- 1.调用后续value.invoke()</span><br><span class="line">- 2.RedisSessionManager.afterRequest()</span><br><span class="line">    - 1.从ThreadLocal中取出当前线程对应的redisSession</span><br><span class="line">    - 2.若有,则复用父类StandardSession.isValid()判断session是否失效</span><br><span class="line">    - 2.1.若未失效,则save()保存session到redis</span><br><span class="line">        - 若SessionPersistPolicy即session持久化策略为ALWAYS_SAVE_AFTER_REQUEST,则通过jedis获取连接,将redisSession序列化成sessionAttributesHash.</span><br><span class="line">        最终存入redis的key是sessionId,value是序列化后的updatedSerializationMetadata.</span><br><span class="line">        设置key的失效时间为session的最大失效时间 jedis.expire(binaryId, getMaxInactiveInterval())</span><br><span class="line">    - 2.2.若session失效,则从redis中remove()掉session</span><br><span class="line">        - 通过jedis.del(session.getId())删除session</span><br></pre></td></tr></table></figure><h2 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h2><p>getSession() 从 redis 中 获取, createSession() 存入 redis.</p><p>load() 和 unload() 都是 空逻辑,因为生命周期交给redis管理了.</p><p>session清理 也不需要做了,向redis中存入key的时候已经设置了key的失效时间.</p><h2 id="see"><a href="#see" class="headerlink" title="@see"></a>@see</h2><p><a href="https://github.com/jcoleman/tomcat-redis-session-manager.git" target="_blank" rel="noopener">tomcat-redis-session-manager github</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tomcat实现分布式session&quot;&gt;&lt;a href=&quot;#tomcat实现分布式session&quot; class=&quot;headerlink&quot; title=&quot;tomcat实现分布式session&quot;&gt;&lt;/a&gt;tomcat实现分布式session&lt;/h1&gt;&lt;p&gt;tomcat
      
    
    </summary>
    
      <category term="Tomcat" scheme="http://yoursite.com/categories/Tomcat/"/>
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat Session机制</title>
    <link href="http://yoursite.com/2019/12/20/01no/tomcat/tomcat03-session/"/>
    <id>http://yoursite.com/2019/12/20/01no/tomcat/tomcat03-session/</id>
    <published>2019-12-19T16:00:00.000Z</published>
    <updated>2020-05-24T11:41:53.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tomcat-session"><a href="#tomcat-session" class="headerlink" title="tomcat session"></a>tomcat session</h1><h2 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.Manager</span><br><span class="line"></span><br><span class="line">StandardManager</span><br><span class="line"></span><br><span class="line">SessionIdGenerator</span><br></pre></td></tr></table></figure><h2 id="Manager实现类"><a href="#Manager实现类" class="headerlink" title="Manager实现类"></a>Manager实现类</h2><p>Manager 用于管理 session.默认实现是 StandardManager,基类 ManagerBase.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Manager</span><br><span class="line">    ClusterManager (org.apache.catalina.ha)</span><br><span class="line">        ClusterManagerBase (org.apache.catalina.ha.session)</span><br><span class="line">            BackupManager (org.apache.catalina.ha.session)</span><br><span class="line">            DeltaManager (org.apache.catalina.ha.session)</span><br><span class="line">    ManagerBase (org.apache.catalina.session)</span><br><span class="line">        PersistentManagerBase (org.apache.catalina.session)</span><br><span class="line">            PersistentManager (org.apache.catalina.session)</span><br><span class="line">        ClusterManagerBase (org.apache.catalina.ha.session)</span><br><span class="line">            BackupManager (org.apache.catalina.ha.session)</span><br><span class="line">            DeltaManager (org.apache.catalina.ha.session)</span><br><span class="line">        StandardManager (org.apache.catalina.session)</span><br></pre></td></tr></table></figure></p><h2 id="StandardManager的实现"><a href="#StandardManager的实现" class="headerlink" title="StandardManager的实现"></a>StandardManager的实现</h2><p>通过 SessionIdGenerator 为每个会话生成,分配一个唯一标识.若集群环境,可配置后面加上tomcat集群标识.</p><p>过期会话处理,在 backgroundProcess() 中.它不断循环判断所有会话中是否有过期的,一旦过期则移除.</p><p>StandContext 停止时,将该 web 应用的所有 session 持久化到磁盘中,文件名 SESSIONS.ser.</p><p>当 web 应用启动时,会加载这些持久化的会话,加载完成后,SESSIONS.ser 将会被删除.</p><h3 id="session获取和创建"><a href="#session获取和创建" class="headerlink" title="session获取和创建"></a>session获取和创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- request.getSession(true)获取session对象,true表示没有则创建session</span><br><span class="line">    - RequestFacade.getSession()</span><br><span class="line">        - connector.Request.getSession()</span><br><span class="line">            - doGetSession()</span><br><span class="line">            - 1.获取StandContext</span><br><span class="line">            - 2.若session不为null,则isValid()校验session是否失效,校验通过直接返回session</span><br><span class="line">            - 3.若上面没有获取到session,则尝试根据requestedSessionId通过manager.findSession()去查找session</span><br><span class="line">            - 4.manager.createSession(sessionId)创建session</span><br><span class="line">                - 1.超过最大允许创建的session数量则报错</span><br><span class="line">                - 2.createEmptySession()创建standardSession对象并设置session超时时间等参数</span><br><span class="line">                - 3.generateSessionId()通过sessionIdGenerator生成sessionId设置到session.id属性中</span><br><span class="line">            - 5.基于刚刚创建的session创建一个新的cookie,其实就是向响应头中添加Set-Cookie: JSESSIONID&#x3D;AA97BC74DD24D2423386C81DB98CED8B; Path&#x3D;&#x2F;books; HttpOnly</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/flyingzc/MyImg/raw/master/img/tomcat/chrome中查看生成的cookie.png" alt="chrome中查看生成的cookie"></p><p><img src="https://gitee.com/flyingzc/MyImg/raw/master/img/tomcat/请求头和响应头中的cookie相关信息.png" alt="请求头和响应头中的cookie相关信息"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- session.setAttribute(KEY, username)设置session属性</span><br><span class="line">    - StandardSessionFacade.setAttribute()</span><br><span class="line">        - StandSession.setAttribute()</span><br><span class="line">            - 保存key-value到protected ConcurrentMap&lt;String, Object&gt; attributes &#x3D; new ConcurrentHashMap&lt;String, Object&gt;();里</span><br></pre></td></tr></table></figure><h3 id="session清理"><a href="#session清理" class="headerlink" title="session清理"></a>session清理</h3><p><img src="https://gitee.com/flyingzc/MyImg/raw/master/img/tomcat/backgroundProcessor后台清理session线程调用栈.png" alt="backgroundProcessor后台清理session线程调用栈"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- ConatinerBase$ContainerBackgroundProcessor.run()</span><br><span class="line">    - StandContext.backgroundProcess()</span><br><span class="line">        - 父类 ContainerBase 逻辑,判断 Manager 不为 null,调用 manager.backgroundProcess().</span><br><span class="line">            - manager.backgroundProcess()控制默认60s才执行一次清理.调用ManagerBase.processExpires()</span><br><span class="line">                - ManagerBase.processExpires()中</span><br><span class="line">                - 1.获取所有sessions</span><br><span class="line">                - 2.遍历每一个session,通过isValid()判断是否失效并处理失效</span><br><span class="line">                    - isValid()里通过当前时间戳,thisAccessedTime,maxInactiveInterval决定是否需要session失效,若失效调用expire()处理</span><br><span class="line">                        - expire()会调用相关sessionListeners,并从ManagerBase里sessions这个map中移除session</span><br></pre></td></tr></table></figure><p>session thisAccessedTime 更新时机.<br>在 StandardSession.thisAccessedTime 属性上 添加 field watchpoint<br>创建session 时默认 thisAccessedTime 值 就是 creationTime<br><img src="https://gitee.com/flyingzc/MyImg/raw/master/img/tomcat/Request回收session调用栈.png" alt="Request回收session调用栈"></p><ol><li><p>tomcat 在处理完请求之后,会对 Request 对象进行回收,并且会回收 Session,此时会更新 thisAccessedTime</p></li><li><p>request.getSession()时,若创建 session,会在 StandardSession.setCreationTime()里更新 thisAccessedTime.若是获取session,会在 StandardSession.access() 里更新 thisAccessedTime 为 当前时间.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tomcat-session&quot;&gt;&lt;a href=&quot;#tomcat-session&quot; class=&quot;headerlink&quot; title=&quot;tomcat session&quot;&gt;&lt;/a&gt;tomcat session&lt;/h1&gt;&lt;h2 id=&quot;相关类&quot;&gt;&lt;a href=&quot;#相关
      
    
    </summary>
    
      <category term="Tomcat" scheme="http://yoursite.com/categories/Tomcat/"/>
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat Lifecycle</title>
    <link href="http://yoursite.com/2019/12/19/01no/tomcat/tomcat01-lifecycle/"/>
    <id>http://yoursite.com/2019/12/19/01no/tomcat/tomcat01-lifecycle/</id>
    <published>2019-12-18T16:00:00.000Z</published>
    <updated>2020-05-24T11:46:07.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LifeCycle"><a href="#LifeCycle" class="headerlink" title="LifeCycle"></a>LifeCycle</h1><h2 id="LifeCycle-相关类"><a href="#LifeCycle-相关类" class="headerlink" title="LifeCycle 相关类"></a>LifeCycle 相关类</h2><p>LifeCycle 接口中的状态扭转注释,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">*            start()</span><br><span class="line">*  -----------------------------</span><br><span class="line">*  |                           |</span><br><span class="line">*  | init()                    |</span><br><span class="line">* NEW -»-- INITIALIZING        |</span><br><span class="line">* | |           |              |     ------------------«-----------------------</span><br><span class="line">* | |           |auto          |     |                                        |</span><br><span class="line">* | |          \|&#x2F;    start() \|&#x2F;   \|&#x2F;     auto          auto         stop() |</span><br><span class="line">* | |      INITIALIZED --»-- STARTING_PREP --»- STARTING --»- STARTED --»---  |</span><br><span class="line">* | |         |                                                            |  |</span><br><span class="line">* | |destroy()|                                                            |  |</span><br><span class="line">* | --»-----«--    ------------------------«--------------------------------  ^</span><br><span class="line">* |     |          |                                                          |</span><br><span class="line">* |     |         \|&#x2F;          auto                 auto              start() |</span><br><span class="line">* |     |     STOPPING_PREP ----»---- STOPPING ------»----- STOPPED -----»-----</span><br><span class="line">* |    \|&#x2F;                               ^                     |  ^</span><br><span class="line">* |     |               stop()           |                     |  |</span><br><span class="line">* |     |       --------------------------                     |  |</span><br><span class="line">* |     |       |                                              |  |</span><br><span class="line">* |     |       |    destroy()                       destroy() |  |</span><br><span class="line">* |     |    FAILED ----»------ DESTROYING ---«-----------------  |</span><br><span class="line">* |     |                        ^     |                          |</span><br><span class="line">* |     |     destroy()          |     |auto                      |</span><br><span class="line">* |     --------»-----------------    \|&#x2F;                         |</span><br><span class="line">* |                                 DESTROYED                     |</span><br><span class="line">* |                                                               |</span><br><span class="line">* |                            stop()                             |</span><br><span class="line">* ---»------------------------------»------------------------------</span><br></pre></td></tr></table></figure></p><p>LifeCycle 实现类,所有主要组件都实现了 LifeCycle 接口.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Container (org.apache.catalina)</span><br><span class="line">    Host (org.apache.catalina)</span><br><span class="line">        TesterHost (org.apache.tomcat.unittest)</span><br><span class="line">        StandardHost (org.apache.catalina.core)</span><br><span class="line">    ContainerBase (org.apache.catalina.core)</span><br><span class="line">        StandardEngine (org.apache.catalina.core)</span><br><span class="line">        StandardWrapper (org.apache.catalina.core)</span><br><span class="line">        StandardHost (org.apache.catalina.core)</span><br><span class="line">        StandardContext (org.apache.catalina.core)</span><br><span class="line">    Wrapper (org.apache.catalina)</span><br><span class="line">        StandardWrapper (org.apache.catalina.core)</span><br><span class="line">            ExistingStandardWrapper in Tomcat (org.apache.catalina.startup)</span><br><span class="line">    Context (org.apache.catalina)</span><br><span class="line">        TesterContext (org.apache.tomcat.unittest)</span><br><span class="line">        FailedContext (org.apache.catalina.startup)</span><br><span class="line">        StandardContext (org.apache.catalina.core)</span><br><span class="line">    Engine (org.apache.catalina)</span><br><span class="line">        StandardEngine (org.apache.catalina.core)</span><br><span class="line">Executor (org.apache.catalina)</span><br><span class="line">    StandardThreadExecutor (org.apache.catalina.core)</span><br><span class="line">LifecycleBase (org.apache.catalina.util)</span><br><span class="line">    StandardPipeline (org.apache.catalina.core)</span><br><span class="line">    LifecycleMBeanBase (org.apache.catalina.util)</span><br><span class="line">    StoreBase (org.apache.catalina.session)</span><br><span class="line">    SessionIdGeneratorBase (org.apache.catalina.util)</span><br><span class="line">WebappClassLoaderBase (org.apache.catalina.loader)</span><br><span class="line">    WebappClassLoader (org.apache.catalina.loader)</span><br><span class="line">    ParallelWebappClassLoader (org.apache.catalina.loader)</span><br><span class="line">Service (org.apache.catalina)</span><br><span class="line">    StandardService (org.apache.catalina.core)</span><br><span class="line">Server (org.apache.catalina)</span><br><span class="line">    StandardServer (org.apache.catalina.core)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- Lifecycle接口</span><br><span class="line">    - 所有需要被生命周期管理的容器 都需要实现该接口</span><br><span class="line">    - 定义生命周期事件,如BEFORE_INIT_EVENT</span><br><span class="line">    - 定义生命周期方法,如init(),start(),stop()</span><br><span class="line">    - 定义监听器操作:添加监听器,查询所有监听器,移除监听器 如addLifecycleListener(),findLifecycleListeners(),removeLifecycleListener()</span><br><span class="line"></span><br><span class="line">- LifecycleBase类</span><br><span class="line">    - Lifecycle接口的基础实现.基本实现逻辑: 比如,当调用standardServer.init()</span><br><span class="line">        - 由于该容器类继承LifecycleBase类,且未重写init()方法, 所以会调用到LifecycleBase.init()方法</span><br><span class="line">            - LifecycleBase.init()方法中先调用 LifecycleBase.setStateInternal(LifecycleState.INITIALIZING, null, false) 变更生命周期状态为LifecycleState.INITIALIZING 这个变更会调用各个事件监听中的 初始化方法</span><br><span class="line">            - 模板方法,调用各个子类容器中的实现逻辑 即initInternal()方法,这个方法一般被子类覆盖,执行子类自己的逻辑 如StandServer.initInternal()</span><br><span class="line">            - 变更状态为初始化完成</span><br><span class="line"></span><br><span class="line">- 各个容器类</span><br><span class="line">    - 实现init()等生命周期方法,且自行调用子容器相应的生命周期方法, 如:standServer.init() 会调用 standardService.init()</span><br><span class="line"></span><br><span class="line">- LifecycleState 生命周期状态枚举类</span><br><span class="line">    - 涉及的状态,如</span><br><span class="line">        - NEW(false, null), INITIALIZING(false, Lifecycle.BEFORE_INIT_EVENT), INITIALIZED(false, Lifecycle.AFTER_INIT_EVENT), STARTING_PREP(false, Lifecycle.BEFORE_START_EVENT), STARTING(true, Lifecycle.START_EVENT), STARTED(true, Lifecycle.AFTER_START_EVENT), STOPPING_PREP(true, Lifecycle.BEFORE_STOP_EVENT), STOPPING(false, Lifecycle.STOP_EVENT), STOPPED(false, Lifecycle.AFTER_STOP_EVENT), DESTROYING(false, Lifecycle.BEFORE_DESTROY_EVENT), DESTROYED(false, Lifecycle.AFTER_DESTROY_EVENT), FAILED(false, null)</span><br><span class="line">    - 生命周期状态转化</span><br><span class="line">        - 如一个容器调用init()后,状态转化为NEW-&gt;INITIALIZING-&gt;INITIALIZED</span><br><span class="line"></span><br><span class="line">- LifecycleSupport 辅助类</span><br><span class="line">    - 用于帮助管理该组件或容器上的监听器,里面维护了一个监听器数组,并提供了注册,移除,触发监听器等方法</span><br></pre></td></tr></table></figure><h2 id="LifeCycle-实现"><a href="#LifeCycle-实现" class="headerlink" title="LifeCycle 实现"></a>LifeCycle 实现</h2><p>简单的说,各个容器会在需要的时候注册不同的 LifecycleListener,在容器启动时会触发状态扭转,每到一个状态就会遍历已经注册到 LifecycleSupport 上的所有listener.如果这个listener实现了对应状态的方法,则会调用该方法的逻辑.</p><h3 id="注册监听流程"><a href="#注册监听流程" class="headerlink" title="注册监听流程"></a>注册监听流程</h3><p>比如 HostConfig, ContextConfig, MapperListener 就实现了 LifecycleListener 接口.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 注册监听 lifecycleBase.addLifecycleListener()</span><br><span class="line">    - lifecycleSupport.addLifecycleListener(listener);</span><br><span class="line">        - lifecycleSupport持有listener数组,和锁对象 </span><br><span class="line">        private LifecycleListener listeners[] &#x3D; new LifecycleListener[0]; </span><br><span class="line">        private final Object listenersLock &#x3D; new Object(); &#x2F;&#x2F; Lock object for changes to listeners </span><br><span class="line">        加锁并创建 lifecycleListener 对象 添加到 listeners 数组中</span><br></pre></td></tr></table></figure><p>LifecycleSupport.addLifecycleListener()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLifecycleListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (listenersLock) &#123;</span><br><span class="line">        LifecycleListener results[] =</span><br><span class="line">        <span class="keyword">new</span> LifecycleListener[listeners.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listeners.length; i++)</span><br><span class="line">            results[i] = listeners[i];</span><br><span class="line">        results[listeners.length] = listener;</span><br><span class="line">        listeners = results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="简要的init-流程"><a href="#简要的init-流程" class="headerlink" title="简要的init()流程"></a>简要的init()流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- LifecycleBase.init() 初始化,会触发初始化前和初始化后的监听 生命周期事件INITIALIZING-&gt;INITIALIZED</span><br><span class="line">    - 1.先判断状态是否为LifecycleState.NEW(默认是)</span><br><span class="line">    - LifecycleBase.setStateInternal(LifecycleState.INITIALIZING, null, false); 变更生命周期状态为LifecycleState.INITIALIZING 调用各个事件监听中的 初始化方法</span><br><span class="line">        - state.getLifecycleEvent(); 获取LifecycleState(生命周期状态)对应的生命周期方法.如INITIALIZING状态对应before_init()方法</span><br><span class="line">        - fireLifecycleEvent(lifecycleEvent, data) 触发生命周期事件.如状态为INITIALIZING对应before_init</span><br><span class="line">            - lifecycleSupport.fireLifecycleEvent() 其中LifecycleSupport对象是LifecycleBase中的成员变量,传入this如StandServer private LifecycleSupport lifecycle &#x3D; new LifecycleSupport(this);</span><br><span class="line">                - 遍历listeners数组,每一个listener都调用lifecycleEvent()</span><br><span class="line">    - 3.initInternal();这个方法一般被子类覆盖,执行子类自己的逻辑</span><br><span class="line">        - 如StandServer.initInternal()逻辑</span><br><span class="line">            - super.initInternal();</span><br><span class="line">    - 容器初始化完毕，LifecycleBase会将容器的状态更改为初始化完毕 setStateInternal(LifecycleState.INITIALIZED, null, false); 这样会导致调用所有listener中的lifecycleEvent()方法,各监听器会在 该方法中根据需要处理INITIALIZED事件</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LifeCycle&quot;&gt;&lt;a href=&quot;#LifeCycle&quot; class=&quot;headerlink&quot; title=&quot;LifeCycle&quot;&gt;&lt;/a&gt;LifeCycle&lt;/h1&gt;&lt;h2 id=&quot;LifeCycle-相关类&quot;&gt;&lt;a href=&quot;#LifeCycle-相关
      
    
    </summary>
    
      <category term="Tomcat" scheme="http://yoursite.com/categories/Tomcat/"/>
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat启动流程</title>
    <link href="http://yoursite.com/2019/12/19/01no/tomcat/tomcat02-start/"/>
    <id>http://yoursite.com/2019/12/19/01no/tomcat/tomcat02-start/</id>
    <published>2019-12-18T16:00:00.000Z</published>
    <updated>2020-05-24T11:45:53.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tomcat-启动"><a href="#tomcat-启动" class="headerlink" title="tomcat 启动"></a>tomcat 启动</h1><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">- Bootstrap.main()</span><br><span class="line">    - Bootstrap bootstrap &#x3D; new Bootstrap(); 实例化Bootstrap实例</span><br><span class="line">    - bootstrap.init(); 1.设置catalinaHome和catalinaBase 2.初始化类加载器,实例化**ClassLoaders</span><br><span class="line">        - setCatalinaHome(); 设置Catalina path,System.getProperty(&quot;catalina.home&quot;),值为tomcat根目录</span><br><span class="line">        - setCatalinaBase(); 值为D:\workspace-e3\.metadata\.plugins\org.eclipse.wst.server.core\tmp2</span><br><span class="line">        - initClassLoaders(); 实例化**ClassLoaders，创建URLClassLoader</span><br><span class="line">            - 初始化classloader,第二个参数为父classLoader commonLoader &#x3D; createClassLoader(&quot;common&quot;, null); catalinaLoader &#x3D; createClassLoader(&quot;server&quot;, commonLoader); sharedLoader &#x3D; createClassLoader(&quot;shared&quot;, commonLoader); 最终执行结果是,创建了commonLoader,catalinaLoader 和 sharedLoader,其中 catalinaLoader 和 sharedLoader 默认均使用 父classLoader: 即 commonLoader</span><br><span class="line">                - bootstrap.createClassLoader()</span><br><span class="line">                    - 读取配置文件中配置的仓库路径(需要加载的jar包的路径) CatalinaProperties.getProperty(name + &quot;.loader&quot;);</span><br><span class="line">                        - CatalinaProperties类中静态块中 static &#123;loadProperties();&#125; 后续从properties中取</span><br><span class="line">                            - loadProperties()方法, 读取catalina.base\\conf\\catalina.properties配置文件到prop属性中 D:\workspace-e3\.metadata\.plugins\org.eclipse.wst.server.core\tmp2\conf\catalina.properties</span><br><span class="line">                    - bootstrap.replace()将$&#123;catalina.home&#125;等替换成具体的路径</span><br><span class="line">                    - 根据逗号截取出每个资源路径</span><br><span class="line">                    - URL url &#x3D; new URL(repository); 先判断是不是网络资源,即先尝试使用URL加载,若它是网络资源则能加载成功, 否则捕获异常接着下面使用本地加载</span><br><span class="line">                    - 本地加载.根据路径结尾以*.jar,.jar或路径,创建不同类型的repository对象</span><br><span class="line">                        - RepositoryType枚举类分类</span><br><span class="line">                            - DIR,&#x2F;&#x2F; 表示整个目录下的资源,包括所有Class,Jar包以及其他类型资源</span><br><span class="line">                            - GLOB,&#x2F;&#x2F; 表示整个目录下所有的Jar包资源,仅仅是.jar后缀的资源</span><br><span class="line">                            - JAR,&#x2F;&#x2F; 表示单个Jar包资源</span><br><span class="line">                            - URL&#x2F;&#x2F; 表示从URL上获取的Jar包资源</span><br><span class="line">                    - 根据以上的repository列表创建classLoader. ClassLoaderFactory.createClassLoader(repositories, parent)</span><br><span class="line">                        - 遍历repositories,判断repositoryType.目的是将每种资源转换为new URL(),并添加到URL[]数组中 </span><br><span class="line">                        0.若是RepositoryType.URL类型的资源,直接new一个URL实例即可 </span><br><span class="line">                        1.若是DIR类型,则根据路径创建java.net.URL对象; </span><br><span class="line">                        2.若是GLOB(这里是E:\Java\apache-tomcat-7.0.82-01\lib),则遍历该目录下的jar包,创建文件,每个jar文件对应一个URL对象;</span><br><span class="line">                        - 最后根据以上所有的url,创建URLClassLoader并返回.该类构造器接收一个URL[]数组类型 return new URLClassLoader(array)</span><br><span class="line">        - Thread.currentThread().setContextClassLoader(catalinaLoader); 为当前线程设置classLoader为catalinaLoader</span><br><span class="line">        - 若启用了安全管理,则会在这里加载一些所需的包(默认不启用) SecurityClassLoad.securityClassLoad(catalinaLoader);</span><br><span class="line">        - 使用catalinaLoader加载catalina类 Class&lt;?&gt; startupClass &#x3D; catalinaLoader.loadClass(&quot;org.apache.catalina.startup.Catalina&quot;); Object startupInstance &#x3D; startupClass.newInstance();</span><br><span class="line">        - 设置catalina对象的parentClassLoader属性为sharedLoader, 由于前面sharedLoader默认使用的是父加载器commonLoader, 所以此处相当于设置为commonLoader org.apache.catalina.startup.Catalina.setParentClassLoader(sharedLoader);</span><br><span class="line">        - bootstrap对象 保存catalina的引用 catalinaDaemon &#x3D; startupInstance;</span><br><span class="line">    - 处理&quot;start&quot;命令</span><br><span class="line">        - 1.setAwait(true) 设置catalina.await&#x3D;true</span><br><span class="line">        - 2.daemon.load(args); 加载配置资源，通过反射调用catalina.load()方法 (1)创建digester实例,digester解析conf&#x2F;server.xml文件 (2)调用Server.init()级联初始化各个组件</span><br><span class="line">            - Catalina中 initDirs() 设置catalina.base和catalina.home和user.dir的property属性, 检查java.io.tmpdir属性是否存在</span><br><span class="line">            - initNaming() 设置java.naming.factory.url.pkgs和java.naming.factory.initia这两个System.setProperty</span><br><span class="line">            - 创建并执行digester,使用digester解析server.xml Digester digester &#x3D; createStartDigester(); Digester类按照预定的规则解析server.xml，将元素转化为对象， 包括构造对象，set属性到对象字段，同时维护相互关联关系</span><br><span class="line">                - new Digester() 创建digester对象</span><br><span class="line">                - digester.addObjectCreate() 1)添加对象创建规则ObjectCreateRule 2)SetPropertiesRule 3)SetNextRule 添加StandardServer等各级容器的关系和处理规则</span><br><span class="line">                - 创建Server实例,默认实现类是StandardServer, 可以通过server节点的className属性指定自己的实现,一般不需要</span><br><span class="line">                - 设置Server属性</span><br><span class="line">                - 调用setServer()将Server设置到Catalina对象中.可在本Catalina类中搜索setServer()方法</span><br><span class="line">                - 创建JNDI实例对象,GlobalNamingResources,并设置其属性.并调用standServer.setGlobalNamingResources()方法装配到server中</span><br><span class="line">                - 为Server添加生命周期监听</span><br><span class="line">                - 创建service实例,创建完成后,通过addService()添加到server中</span><br><span class="line">                - 为server添加生命周期监听器.默认未指定监听器,347行的null</span><br><span class="line">                - 为service添加Executor</span><br><span class="line">                - 为service添加Connector</span><br><span class="line">                - 设置属性时,将executor属性排除在外.因为Connector创建时,即ConnectorCreateRule类中, 会判断当前是否指定了executor属性.若是,则从Service中查找该名称的executor并设置到Connector中.</span><br><span class="line">                - 为Connector添加 生命周期监听器.默认未指定</span><br><span class="line">                - 添加子元素解析规则.这部分指定了Servlet容器相关的各级嵌套子节点的解析规则. 且每类嵌套子节点的解析封装为一个RuleSet类(跟进去看).包括GlobalNamingResources,Engine,Context,Cluster的解析</span><br><span class="line">            - 使用sax读取server.xml file &#x3D; configFile();</span><br><span class="line">            - digester.parse(inputSource); 使用digester解析读取的xml,在此过程中会初始化各个组件实例及其依赖关系. 最后会把server.xml文件中的内容解析到StandardServer中 (创建standServer对象并维护对象间关系)</span><br><span class="line">                - configure();</span><br><span class="line">                - getXMLReader().parse(input);</span><br><span class="line">                    - ......</span><br><span class="line">                        - 经过java里SAXPaser解析InputSource后,调用Digester.startElement()</span><br><span class="line">                            - 遍历rules rule.begin(namespaceURI, name, list); 分别创建StandardServer实例</span><br><span class="line">                                - new StandardServer()构造器</span><br><span class="line">                                    - new NamingResources()</span><br><span class="line">                                    - new NamingContextListener() addLifecycleListener(namingContextListener);</span><br><span class="line">                                - setPropertiesRule()</span><br><span class="line">                            - standardService.addConnector()</span><br><span class="line">                            - standardServer.addService() 向server中添加一个新的service. digester在xml解析时会注入这个关系</span><br><span class="line">                            - digester解析会做很多初始化操作,以后细化...</span><br><span class="line">                            - Connector con &#x3D; new Connector(attributes.getValue(&quot;protocol&quot;)); 创建Connector,会有多个Connector,和xml中配置的数量有关</span><br><span class="line">                                - Connector构造器</span><br><span class="line">                                    - setProtocol(protocol);</span><br><span class="line">                                        - 根据xml配置的协议类型,此处是Http11Protocol setProtocolHandlerClassName (&quot;org.apache.coyote.http11.Http11Protocol&quot;);</span><br><span class="line">                                    - 实例化Http11Protocol</span><br><span class="line">                                        - Http11Protocol构造器</span><br><span class="line">                                            - endpoint &#x3D; new JIoEndpoint();</span><br><span class="line">            - getServer().init(); 调用Server的init()方法,初始化各个组件. 它会调用各个service子容器的init()方法, 从而级联完成组件初始化 在调用init()时第3步,调用子类StandardService.initInternal(); 各个组件有个共同的父类: LifecycleBase,用于管理组件的生命周期和状态变化。 在走Server.init()前,先走父类LifecycleBase.init(),事件驱动当前组件状态的变化. 从StandardServer到StandardWrapper,都会调用initInternal(), 并伴随调用共有父类LifecycleBase.init()</span><br><span class="line">                - init()方法在父类LifecycleBase中, 调用父类LifecycleBase.init()</span><br><span class="line">                    - super.initInternal(); 即父类LifecycleBase.initInternal()</span><br><span class="line">                        - 1.先判断状态是否为LifecycleState.NEW(默认是)  </span><br><span class="line">                          2.LifecycleBase.setStateInternal(LifecycleState.INITIALIZING, null, false); 变更生命周期状态为LifecycleState.INITIALIZING 调用各个事件监听中的 初始化方法</span><br><span class="line">                        - 3.initInternal();这个方法一般被子类覆盖,执行子类自己的逻辑 此处为StandServer.initInternal()</span><br><span class="line">                            - StandServer.initInternal()中 super.initInternal(); 调用父类LifecycleMBeanBase.initInternal()</span><br><span class="line">                                - LifecycleMBeanBase.initInternal()中 将容器托管到JMX，便于运维管理</span><br><span class="line">                            - 遍历services调用service.init() services[i].init();</span><br><span class="line">                                - StandardService.init()中 init()方法在父类LifecycleBase中, 调用父类LifecycleBase.init()</span><br><span class="line">                                    - LifecycleBase.init()中 setStateInternal(LifecycleState.INITIALIZING, null, false); 变更生命周期状态为LifecycleState.INITIALIZING(通过事件变更)</span><br><span class="line">                                    - initInternal();&#x2F;&#x2F; 进入子类的initInternal()方法, 即调用StandardService.initInternal()</span><br><span class="line">                                        - StandardService.initInternal()中 container.init(); 此处container即为StandardEngine.init()  StandardEngine的子容器standardContext及其子容器没有init初始化逻辑</span><br><span class="line">                                            - StandardEngine.init()中,略去LifecycleBase中生命周期变更的重复逻辑 StandardEngine.initInternal()中 getRealm(); 创建realm</span><br><span class="line">                                            - super.initInternal(); 即为ContainerBase.initInternal() Engine,Host,Context,Wrapper容器都拥有共同父类ContainerBase</span><br><span class="line">                                                - ContainerBase.initInternal()中 startStopExecutor &#x3D; new ThreadPoolExecutor() 初始化startStopExecutor,用于管理启动和关闭的线程</span><br><span class="line">                                                - super.init()即LifecycleMBeanBase.initInternal()</span><br><span class="line">                                                    - ......略去各个StandardHost.init()</span><br><span class="line">                                                        - ...</span><br><span class="line">                                                            - lifecycleBase.init()</span><br><span class="line">                                                                - LifecycleBase.setStateInternal(LifecycleState.INITIALIZED, null, false);初始化完成 StandardContext父类LifecycleBase变更生命周期状态,调用各个事件监听中的 initializing</span><br><span class="line">                                                                - initInternal();&#x2F;&#x2F; 进入子类StandardContext.initInternal()方法</span><br><span class="line">                                                                    - super.initInternal(); StandardContext.initInternal()调用父类ContainerBase.initInternal() 它会创建startStopExecutor 并调用父类LifecycleMBeanBase.initInternal(); 这里会将容器托管到JMX</span><br><span class="line">                                                                    - this.addLifecycleListener(new TldConfig()); 添加TldConfig监听</span><br><span class="line">                                                                - setStateInternal(LifecycleState.INITIALIZED, null, false); &#x2F;&#x2F; 更新组件生命周期状态为LifecycleState.INITIALIZED</span><br><span class="line">                                                                    - ...</span><br><span class="line">                                                                        - contextConfig.lifecycleEvent() contextConfig AFTER_INIT_EVENT生命周期事件处理</span><br><span class="line">                                                                            - contextConfig.init(); context初始化阶段,context属性配置 tomcat提供的默认配置添加到context实例 完成对应的 每个web应用项目的配置解析(web.xml)</span><br><span class="line">                                                                                - createContextDigester()</span><br><span class="line">                                                                                - contextDigester.getParser();</span><br><span class="line">                                                                                - contextConfig(contextDigester);  解析config.xml配置 E:\Java\apache-tomcat-7.0.82-01\conf\context.xml</span><br><span class="line">                                                                                - createWebXmlDigester()</span><br><span class="line">                                                                            - beforeStart() Lifecycle.BEFORE_START_EVENT状态</span><br><span class="line">                                        - executor.init(); 初始化executors,即tomcat间可共享的线程池</span><br><span class="line">                                        - connector初始化</span><br><span class="line">                                            - connector.initInternal();</span><br><span class="line">                                                - adapter &#x3D; new CoyoteAdapter(this); 构建与指定连接器关联的新CoyoteAdapter</span><br><span class="line">                                                - protocolHandler.setAdapter(adapter); 给 协议处理器 添加 adapter</span><br><span class="line">                                                - protocolHandler.init(); 初始化具体协议类型，如Http11Protocol协议</span><br><span class="line">                                                    - AbstractHttp11JsseProtocol.init()</span><br><span class="line">                                                        - endpoint初始化之前,需要初始化ssl实现类 sslImplementation &#x3D; SSLImplementation.getInstance(sslImplementationName); return new org.apache.tomcat.util.net.jsse.JSSEImplementation();</span><br><span class="line">                                                        - super.init(),即AbstractProtocol.init() 1.注册组件JIoEndPoint;  2.endpoint.init() 设置work threads的数量，默认为200，并创建serverSocket对象</span><br><span class="line">                                                            - abstractProtocol.bind() 设置线程数,网络连接数</span><br><span class="line">                                                                - 初始化acceptor线程数量,默认1个; 初始化最大连接数,此值为server.xml的connector元素的属性MaxThreads值，(若不设置则)默认200</span><br><span class="line">                                                                - abstractEndpoint.getMaxThreadsWithExecutor() 返回成员变量maxThreads&#x3D;200</span><br><span class="line">                                                                - abstractEndpoint.setMaxConnections(getMaxThreadsWithExecutor()); 设置最大连接数</span><br><span class="line">                                                                    - initializeConnectionLatch(); 创建LimitLatch对象并初始化连接数 即 connectionLimitLatch &#x3D; new LimitLatch(getMaxConnections());</span><br><span class="line">                                                                - serverSocketFactory &#x3D; new DefaultServerSocketFactory(this); 创建ServerSocketFactory</span><br><span class="line">                                                                - serverSocket &#x3D; serverSocketFactory.createSocket(getPort(),getBacklog()); 创建serverSocket</span><br><span class="line">                                                - 初始化mapper listener mapperListener.init();</span><br><span class="line">                        - 容器初始化完毕，LifecycleBase会将容器的状态更改为初始化完毕 setStateInternal(LifecycleState.INITIALIZED, null, false);</span><br><span class="line">        - 3.daemon.start().即catalina.start() 运行各个组件,容器开始启动.</span><br><span class="line">            - getServer().start() 启动Server 即standardServer.start(),由于未重写该方法. 所以会先调用父类LifecycleBase.start()</span><br><span class="line">                - LifecycleBase.start()中 setStateInternal(LifecycleState.STARTING_PREP, null, false); &#x2F;&#x2F; 启动前将状态设置为LifecycleState.STARTING_PREP</span><br><span class="line">                - startInternal(); &#x2F;&#x2F; 模板方法调用子类逻辑</span><br><span class="line">                    - StandardServer.startInternal();中 1.发布configure_start事件 fireLifecycleEvent(CONFIGURE_START_EVENT, null);</span><br><span class="line">                    - 2.设置状态为starting setState(LifecycleState.STARTING);  3.globalNamingResources.start(); globalNamingResources.start();</span><br><span class="line">                    - 4.services[i].start(); 启动多个Service子容器. 略去LifecycleBase.start()的重复逻辑, 调用standardService.startInternal()</span><br><span class="line">                        - standardService.startInternal()中 container.start(): 启动container,此时container为StandardEngine</span><br><span class="line">                            - StandardEngine.startInternal()中 调用super.startInternal(), 即ContainerBase.startInternal()</span><br><span class="line">                                - ContainerBase.startInternal()中 若配置了loader,manager,cluster,realm等,则会启动这些下属组件.  在engine,host,context等容器的启动逻辑都会调用该父类(ContainerBase)的此方法用于加载启动子容器. containerBase.startInternal()会向线程池 提交启动子容器的任务,并阻塞等待子容器启动的返回结果判定是否启动成功</span><br><span class="line">                                    - ContainerBase.startInternal()中 getLoaderInternal()</span><br><span class="line">                                        - Lock readLock &#x3D; loaderLock.readLock(); readLock.lock(); try &#123;     return loader; &#125; finally &#123;     readLock.unlock(); &#125;</span><br><span class="line">                                    - 若配置了realm组件,则启动 Realm realm &#x3D; getRealmInternal();  if ((realm !&#x3D; null) &amp;&amp; (realm instanceof Lifecycle))      ((Lifecycle) realm).start();</span><br><span class="line">                                    - 若有子容器,则启动 Container children[] &#x3D; findChildren();</span><br><span class="line">                                    - results.add(startStopExecutor.submit(new StartChild(children[i]))); 提交启动子容器的任务,后续StandHost的操作会在新线程中完成</span><br><span class="line">                                        - StartChild.call() class StartChild implements Callable&lt;Void&gt; StartChild类实现Callable,会执行覆写的call()方法</span><br><span class="line">                                            - child.start(); 启动子容器,比如此处Engine的子容器就是Host 即调用standHost.start()</span><br><span class="line">                                                - StandardHost.start() 使用父类LifecycleBase中的start()方法</span><br><span class="line">                                                    - LifecycleBase.start()中</span><br><span class="line">                                                        - LifecycleBase.start()中 setStateInternal(LifecycleState.STARTING_PREP, null, false); 触发before_start事件,即Host容器发布before_start事件, 相关监听器会接收到通知,执行相应逻辑,如HostConfig监听器</span><br><span class="line">                                                            - HostConfig.lifecycleEvent() HostConfig实现LifecycleListener接口,在StandardHost启动时生命周期发生变化时, 会调用HostConfig的lifecycleEvent()对特定事件进行逻辑处理</span><br><span class="line">                                                                - 调用HostConfig.beforeStart() BEFORE_START_EVENT</span><br><span class="line">                                                                    - beforeStart() 会创建appBase和configBase路径所需的目录</span><br><span class="line">                                                                        - 判断host.getCreateDirs(),对appBase和configBase进行mkdirs()</span><br><span class="line">                                                        - lifecycleBase.startInternal(); 会调用子类StandardHost.startInternal()</span><br><span class="line">                                                            - StandardHost.startInternal()中 Valve[] valves &#x3D; getPipeline().getValves();</span><br><span class="line">                                                                - 获取错误阀的阀名,即org.apache.catalina.valves.ErrorReportValve getErrorReportValveClass()</span><br><span class="line">                                                                - 若有错误阀名,尝试遍历所有阀找出这个class类 StandardPipline.getValues() 通过value.getNext()循环遍历将所有Value成数组返回</span><br><span class="line">                                                                - 若没有找到,则反射创建实例,并添加到pipeline中</span><br><span class="line">                                                            - super.startInternal(); 调用ContainerBase.startInternal()新起线程启动子容器(即Host的Context子容器)</span><br><span class="line">                                                                - ContainerBase.startInternal()中 results.add(startStopExecutor.submit(new StartChild(children[i]))); 启动StandardContext!!!!!!后续子节点都是Context容器的操作</span><br><span class="line">                                                                    - 调用StandardContext.start(), 由于该类未重写start(), 所以实际上调用父类lifecycleBase.start()</span><br><span class="line">                                                                        - lifecycleBase.start()中 若是LifecycleState.NEW状态</span><br><span class="line">                                                                        - LifecycleBase.setStateInternal(LifecycleState.STARTING_PREP, null, false); 设置LifecycleState.STARTING_PREP状态,即before_start</span><br><span class="line">                                                                            - 调用ContextConfig.beforeStart(); &#x2F;&#x2F; 在context启动前触发,用于更新Context的docBase属性 和 解决web目录锁的问题</span><br><span class="line">                                                                        - LifecycleBase.startInternal();</span><br><span class="line">                                                                            - 调用子类StandardContext.startInternal() 完成对web应用的初始化工作</span><br><span class="line">                                                                                - StandardContext.startInternal()里经过一系列操作,将状态变更为CONFIGURE_START_EVENT standardContext.fireLifecycleEvent(Lifecycle.CONFIGURE_START_EVENT, null); 发布CONFIGURE_START_EVENT事件,contextConfig监听以完成servlet创建</span><br><span class="line">                                                                                    - contextConfig.configureStart(); web应用初始化.解析web.xml文件, 创建wrapper,Filter,ServletContextListener等.</span><br><span class="line">                                                                                        - contextConfig.webConfig()</span><br><span class="line">                                                                                            - webXml.configureContext(context); 解析web.xml,将webXml对象设置给context</span><br><span class="line">                                                                                                - Lin1388 webXml.configureContext(context); 解析servlet,将Servlet包装成Wrapper</span><br><span class="line">                                                                                                    - context.createWrapper()</span><br><span class="line">                                                                                                    - wrapper.setServletClass(servlet.getServletClass()); 将wrapper与servlet绑定</span><br><span class="line">                                                                                                    - context.addChild(wrapper); 将wrapper添加到context中</span><br><span class="line">                                                                                                        - containerBase.addChildInternal(child);</span><br><span class="line">                                                                                                            - child.start(); 即standardWraper.start()</span><br><span class="line">                                                                                                                - Wrapper容器 StandardWrapper.start()</span><br><span class="line">                                                                        - LifecyclesetStateInternal(LifecycleState.STARTED, null, false); 设置LifecycleState.STARTED状态,即after_start</span><br><span class="line">                                                                            - 调用context.setDocBase(originalDocBase);</span><br><span class="line">                                                                        - containerBase.threadStart(); 启动Context层级的后台任务进程.Cluster后台任务(包括部署变更检测,心跳).Pipeline中Value的后台任务处理(如果有定时处理任务)</span><br><span class="line">                                                                - ContainerBase.startInternal()中 setState(LifecycleState.STARTING); 设置容器状态为STARTING,此时会触发START_EVENT生命周期事件.即start事件</span><br><span class="line">                                                                    - 调用HostConfig.start(); Host启动时触发,完成服务器启动过程中的 Web应用部署. 需要 Host的deployOnstartup&#x3D;&quot;true&quot;才会在服务器启动时部署web应用. </span><br><span class="line">                                    - 若有管道,则启动 if (pipeline instanceof Lifecycle)     ((Lifecycle) pipeline).start();</span><br><span class="line">                        - executor.start(); 启动service容器的多个线程池executors</span><br><span class="line">                        - connector.start(); 启动service组件的多个connector</span><br><span class="line">                            - connector.startInternal()</span><br><span class="line">                                - protocolHandler.start(); 启动 协议处理器</span><br><span class="line">                                    - endpoint.start();</span><br><span class="line">                                        - createExecutor(); 创建endpoint私有的线程池,即ThreadPoolExecutor线程池</span><br><span class="line">                                            - abstractEndpoint.createExecutor()</span><br><span class="line">                                                - new TaskQueue(); 用来运行线程池执行器的任务队列,该类extends LinkedBlockingQueue&lt;Runnable&gt;  new TaskThreadFactory()  implements ThreadFactory 线程工厂,用于创建并返回线程  executor &#x3D; new ThreadPoolExecutor() 根据前两者 创建线程池</span><br><span class="line">                                        - initializeConnectionLatch(); 创建LimitLatch对象,之前init时已经创建.此处直接返回</span><br><span class="line">                                        - startAcceptorThreads(); 创建多个Acceptors</span><br><span class="line">                                            - getAcceptorThreadCount(); 获取acceptor线程数量,默认1</span><br><span class="line">                                            - return new JIoEndpoint.Acceptor() implements Runnable; 创建JIoEndpoint</span><br><span class="line">                                            - Thread t &#x3D; new Thread(acceptors[i], threadName); 根据JIoEndpoint创建线程,且是守护线程</span><br><span class="line">                                - mapperListener.start(); 启动 mapperListener</span><br><span class="line">                                    - findDefaultHost(); 从engine中获取defaultHost并设置给mapper</span><br><span class="line">                                        - 从engine中获取defaultHost并设置给mapper mapper.setDefaultHostName(defaultHost);</span><br><span class="line">                                    - addListeners(engine);</span><br><span class="line">                                        - container.addContainerListener(this); container.addLifecycleListener(this); addListeners(child); 其中this为engine,child为host.即给engine注册监听</span><br><span class="line">                                    - registHost() 向mapper注册host及其下的context,wrapper</span><br><span class="line">                                        - mapper.addHost(host.getName(), aliases, host);</span><br><span class="line">                                        - registerContext((Context) container); 向mapper注册context</span><br><span class="line">                                            - prepareWrapperMappingInfo(context, (Wrapper) container, wrappers);</span><br></pre></td></tr></table></figure><h2 id="bootstrap-init"><a href="#bootstrap-init" class="headerlink" title="bootstrap.init()"></a>bootstrap.init()</h2><p>创建 commonClassLoader,和 两个子 类加载器 catalinaLoader 和 sharedLoader,当然都是 URLClassLoader 实例,加载 一些 Jar.</p><p>设置当前线程的上下文类加载器为 catalinaLoader</p><p>设置 Catalina 的 父类加载器为 sharedLoader</p><h2 id="处理-start-命令"><a href="#处理-start-命令" class="headerlink" title="处理 start 命令"></a>处理 start 命令</h2><p>分为 load 和 start 两步</p><h3 id="load"><a href="#load" class="headerlink" title="load"></a>load</h3><p>读取 conf/server.xml 配置,使用 digester 解析,组装对象.</p><p>server.init() 主要遍历 services,调用其 init() 方法<br>状态变更: LifecycleState.NEW -&gt; LifecycleState.INITIALIZING -&gt; initInternal() -&gt; LifecycleState.INITIALIZED</p><p>service.init()<br>调用 engine.init(),初始化executor,遍历初始化 connectors</p><p>Connector.init()<br>创建 CoyoteAdapter<br>protocolHandler 关联 adapter<br>protocolHandler.init(),这里面会初始化 endpoint<br>mapperListener.init()</p><p>StandEngine.init()<br>engine,host,context,wrapper 都继承自 ContainerBase,ContainerBase里会起 startStopExecutor 线程池,这个线程池用于子容器启动,父容器会等待子容器启动完成.</p><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>Catalina.start()<br>调用 server.start()</p><p>StandardServer.start()<br>触发 CONFIGURE_START_EVENT 事件,设置自身的状态为 STARTING,遍历调用 services.start()</p><p>StandService.start()<br>设置状态为 STARTING,调用 engine.start(),excutors.start(),connector.start()</p><p>StandEngine.start()<br>会走父类 ContainerBase.startInternal(),在 ContainerBase 中,若配了 loader,manager, cluster, realm 则 启动.<br>然后就查找所有子容器,每个子容器都交由 startStopExecutor 线程池 执行 StartChild 的逻辑,调用 child.start().并通过 future.get() 阻塞等待所有子容器启动成功.<br>pipeline.start()<br>设置线程状态为 STARTING,触发 START_EVENT 生命周期事件.<br>启动一个 ContainerBackgroundProcessor 后台线程.</p><p>ContainerBase.startInternal()代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="comment">// Start our subordinate components, if any.启动下属组件</span></span><br><span class="line">    Loader loader = getLoaderInternal();</span><br><span class="line">    <span class="keyword">if</span> ((loader != <span class="keyword">null</span>) &amp;&amp; (loader <span class="keyword">instanceof</span> Lifecycle))<span class="comment">// 若配置了loader则启动</span></span><br><span class="line">        ((Lifecycle) loader).start();</span><br><span class="line">    logger = <span class="keyword">null</span>;</span><br><span class="line">    getLogger();</span><br><span class="line">    Manager manager = getManagerInternal();</span><br><span class="line">    <span class="keyword">if</span> ((manager != <span class="keyword">null</span>) &amp;&amp; (manager <span class="keyword">instanceof</span> Lifecycle))</span><br><span class="line">        ((Lifecycle) manager).start();</span><br><span class="line">    Cluster cluster = getClusterInternal();</span><br><span class="line">    <span class="keyword">if</span> ((cluster != <span class="keyword">null</span>) &amp;&amp; (cluster <span class="keyword">instanceof</span> Lifecycle))<span class="comment">// 若配置了集群,则启动</span></span><br><span class="line">        ((Lifecycle) cluster).start();</span><br><span class="line">    Realm realm = getRealmInternal();</span><br><span class="line">    <span class="keyword">if</span> ((realm != <span class="keyword">null</span>) &amp;&amp; (realm <span class="keyword">instanceof</span> Lifecycle))<span class="comment">// 若配置了安全组件Realm,则启动</span></span><br><span class="line">        ((Lifecycle) realm).start();</span><br><span class="line">    DirContext resources = getResourcesInternal();</span><br><span class="line">    <span class="keyword">if</span> ((resources != <span class="keyword">null</span>) &amp;&amp; (resources <span class="keyword">instanceof</span> Lifecycle))</span><br><span class="line">        ((Lifecycle) resources).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start our child containers, if any.启动子容器,如果有的话.</span></span><br><span class="line">    Container children[] = findChildren();</span><br><span class="line">    List&lt;Future&lt;Void&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;Future&lt;Void&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123; <span class="comment">// 提交 启动子容器的任务.并阻塞当前线程等待执行结果</span></span><br><span class="line">        results.add(startStopExecutor.submit(<span class="keyword">new</span> StartChild(children[i]))); <span class="comment">// 子容器使用 startStopExecutor 调用新线程来启动</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> fail = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Future&lt;Void&gt; result : results) &#123; <span class="comment">// 启动 多个子容器的执行结果</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result.get(); <span class="comment">// 阻塞直到所有子容器启动完毕</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(sm.getString(<span class="string">"containerBase.threadedStartFailed"</span>), e);</span><br><span class="line">            fail = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fail) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">                sm.getString(<span class="string">"containerBase.threadedStartFailed"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the Valves in our pipeline (including the basic), if any.启动容器持有的Pipeline组件的Value.若有管道,则启动</span></span><br><span class="line">    <span class="keyword">if</span> (pipeline <span class="keyword">instanceof</span> Lifecycle)</span><br><span class="line">        ((Lifecycle) pipeline).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置容器状态为STARTING,此时会触发START_EVENT生命周期事件.</span></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start our thread. 启动该层级的后台定时任务进程(不同容器调用,则启动不同容器的后台线程).用于处理如 Cluster 后台任务(包括部署变更检测,心跳).Realm 后台任务处理.Pipeline 中 Value 的后台任务处理(如果有定时处理任务)</span></span><br><span class="line">    threadStart();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>StandardHost.startInternal()<br>不存在errorValve则创建,调用 ContainerBase.startInternal() 启动子容器.子容器是在 HostConfig.deployXxx里通过<code>host.addChild(context)</code>添加进来的.</p><p>StandContext.startInternal()<br>创建 WebappLoader 并启动<br>触发 CONFIGURE_START_EVENT 事件,contextConfig 监听以完成 servlet 创建<br>遍历启动子容器<br>启动pipline<br>触发listener的各种事件<br>初始化filter<br>初始化servlets,调用 load-on-startup 的 servlet 的 init() 方法<br>遍历 wraper,调用 wrapper.load() 加载 wrapper</p><p>StandWrapper.startInternal()<br>没什么重要逻辑</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tomcat-启动&quot;&gt;&lt;a href=&quot;#tomcat-启动&quot; class=&quot;headerlink&quot; title=&quot;tomcat 启动&quot;&gt;&lt;/a&gt;tomcat 启动&lt;/h1&gt;&lt;h2 id=&quot;启动流程&quot;&gt;&lt;a href=&quot;#启动流程&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Tomcat" scheme="http://yoursite.com/categories/Tomcat/"/>
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="http://yoursite.com/2019/12/18/01no/struct/BloomFilter/"/>
    <id>http://yoursite.com/2019/12/18/01no/struct/BloomFilter/</id>
    <published>2019-12-17T16:00:00.000Z</published>
    <updated>2020-03-14T03:55:28.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p>布隆过滤器(Bloom Filter).是一个很长的 二进制向量 和 一系列随机映射 函数.</p><p>之所以叫 filter,是在缓存之前,把不存在的 key 给拦截掉.</p><p>本质是 一个位数组: 位数组 就是 数组 的 每个元素 都只占用 1 bit,并且每个元素只能是 0 或 1.</p><p><code>用于判断: 某个元素 一定不存在 或者 可能存在 于 一个集合中.</code></p><p>布隆过滤器除了一个位数组,还有 K 个哈希函数.</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>一个元素加入布隆过滤器:<br>使用 K 个 哈希函数 对元素值 进行 K 次计算,得到 K 个哈希值.<br>根据得到的哈希值,在 位数组中 把对应下标的值置为 1.</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>当查询 w 是否存在时,可以再通过这 k 个 哈希函数,如果算出来所在的位置均为1,则表示 w 可能存在(注意是可能存在),否则一定不存在.</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>1.优点<br>空间效率 和 查询时间 都远远超过一般的算法.</p><p>2.缺点<br>有一定的 误识别率 和 删除困难</p><p>数组的容量即使再大,也是有限的.</p><p>随着元素的增加,插入的元素就会越多,位数组中被置为 1 的位置因此也越多.</p><p>这就会造成一种情况:<br>当一个不在布隆过滤器中的元素,经过同样规则的哈希计算之后,得到的值在位数组中查询,有可能这些位置因为之前其它元素的操作先被置为 1 了.</p><p><code>有可能一个不存在 布隆过滤器 中的 会被误判成 在布隆过滤器中.</code></p><p><code>布隆过滤器说某个元素在,可能会被误判.</code><br><code>布隆过滤器说某个元素不在,那么一定不在.</code></p><h2 id="Guava-BloomFilter"><a href="#Guava-BloomFilter" class="headerlink" title="Guava BloomFilter"></a>Guava BloomFilter</h2><p>使用api</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 BloomFilter</span></span><br><span class="line">BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(Funnels.unencodedCharsFunnel(), SIZE);</span><br><span class="line"><span class="comment">// 存入数据到 BloomFilter</span></span><br><span class="line">bloomFilter.put(data);</span><br><span class="line"><span class="comment">// 查询s是否在 BloomFilter 中</span></span><br><span class="line">bloomFilter.mightContain(s)</span><br></pre></td></tr></table></figure><h2 id="Redis-BloomFilter"><a href="#Redis-BloomFilter" class="headerlink" title="Redis BloomFilter"></a>Redis BloomFilter</h2><p>redis 布隆过滤器的插件 rebloom</p><p>BF.ADD 向布隆过滤器中插入数据的命令,插入成功返回 true</p><p>BF.EXISTS 判断布隆过滤器中是否存在该数据命令,存在返回true</p><h3 id="Redis-引入-BloomFilter-的原因"><a href="#Redis-引入-BloomFilter-的原因" class="headerlink" title="Redis 引入 BloomFilter 的原因"></a>Redis 引入 BloomFilter 的原因</h3><p>数据量较大时,解决缓存穿透</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/yudiandemingzi/spring-boot-redis-lua" target="_blank" rel="noopener">redis bloomFilter demo</a></p><p><a href="https://github.com/topics/bloom-filter" target="_blank" rel="noopener">bloom filter topic</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;布隆过滤器&quot;&gt;&lt;a href=&quot;#布隆过滤器&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器&quot;&gt;&lt;/a&gt;布隆过滤器&lt;/h1&gt;&lt;h2 id=&quot;what&quot;&gt;&lt;a href=&quot;#what&quot; class=&quot;headerlink&quot; title=&quot;what&quot;
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis实现分布式锁</title>
    <link href="http://yoursite.com/2019/12/17/01no/redis/redis10-lock/"/>
    <id>http://yoursite.com/2019/12/17/01no/redis/redis10-lock/</id>
    <published>2019-12-16T16:00:00.000Z</published>
    <updated>2020-05-24T11:46:52.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h1><h2 id="要考虑的点"><a href="#要考虑的点" class="headerlink" title="要考虑的点"></a>要考虑的点</h2><ol><li>互斥(独占,只能有一个客户端获取锁)</li><li>不能死锁</li><li>容错(只要大部分 redis 节点创建了这把锁就认为成功获取到锁)</li><li>支持重入,超时获取锁等特性</li></ol><h2 id="redis实现分布式锁"><a href="#redis实现分布式锁" class="headerlink" title="redis实现分布式锁"></a>redis实现分布式锁</h2><h3 id="1-使用set"><a href="#1-使用set" class="headerlink" title="1.使用set"></a>1.使用set</h3><h4 id="1-1-加锁"><a href="#1-1-加锁" class="headerlink" title="1.1.加锁"></a>1.1.加锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key randomValue NX PX 30000</span><br></pre></td></tr></table></figure><p>NX: (not exists)表示只有 key 不存在的时候才会设置成功.(如果此时 redis 中存在这个 key,那么设置失败,返回 nil)<br>PX 30000: 30s 后 key 失效,意味着 30s 后锁自动释放.</p><p>随机数 randomValue 可以使用 时间戳 + 客户端编号 的方式 生成随机数.</p><h4 id="1-2-释放锁"><a href="#1-2-释放锁" class="headerlink" title="1.2.释放锁"></a>1.2.释放锁</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除锁的时候,找到 key 对应的 value,跟自己传过去的 value 做比较,如果是一样的才删除.保证解的是自己加的锁</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果 key 对应的 value 一致,则删除这个 key.</p><p>通过这个方式释放锁是为了避免 Client 释放了其他 Client 申请的锁.</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>这种加的是单机的 redis 锁,会有单点故障问题.</p><p>1.单点故障<br>如果是 redis 单实例,那就是单点故障.</p><p>如果是 redis 主从架构,即使有 redis 主从异步复制.如果 master 节点挂了(key 就没有了),key 还没同步到 slave 节点,此时 slave 节点 切换为 master 节点,别人就可以 set key,从而拿到锁.</p><p>2.超时释放锁的问题<br>1.client A 获得锁成功<br>2.client B 等待 A 释放锁<br>3.client A 超时没释放锁(比如 full gc)<br>4.redis 删除掉 key,释放锁<br>5.client B 获得锁成功<br>6.client B 做修改操作<br>7.client A 恢复做修改操作,覆盖了 client B 的修改</p><h4 id="在上面基础上-加-乐观锁"><a href="#在上面基础上-加-乐观锁" class="headerlink" title="在上面基础上 加 乐观锁"></a>在上面基础上 加 乐观锁</h4><p>在lua脚本中,获取锁成功的同时,使用<code>redis.call(&quot;INCRBY&quot;, key, &quot;1&quot;)</code>返回一个单调递增的version.<br>这样假设 A 超时锁被 redis server 释放掉,此时 B 获得锁更新数据成功.A试图更新数据时判断A的版本号低于现在数据的版本号,则不允许A更改.</p><h3 id="2-RedLock-实现"><a href="#2-RedLock-实现" class="headerlink" title="2.RedLock 实现"></a>2.RedLock 实现</h3><h4 id="RedLock-原理"><a href="#RedLock-原理" class="headerlink" title="RedLock 原理"></a>RedLock 原理</h4><p>假设有 N 个 Redis master 节点,不考虑主从复制.<br>像在 Redis 单实例上一样获取 和 释放锁.<br>假设有 5 台 Redis 实例,这样同时宕机的概率很低.</p><p>获取锁流程:<br>1.获取当前时间</p><p>2.依次尝试从 5 个实例上,使用相同的 key 和 唯一的value 获取锁.<br>client 设置一个 网络连接 和 超时响应时间,远小于锁的失效时间.(这能避免 Redis 实例挂了,client 一直等待获得锁的响应).<br>若 server 没有在规定时间内响应,client 应立即尝试去另外一个 Redis 实例上 请求获取锁.</p><p>3.client 使用 当前时间 减去 开始获取锁的时间(1中的时间),得到的就是 获取锁使用的时间.<code>当 过半 Redis 节点都获取到锁,且 使用的时间 小于 锁失效时间,锁才算获取成功.</code></p><p>4.若成功获取锁,key的失效时间 等于 有效时间 减去 获取锁使用的时间(3中得到的时间).</p><p>5.若获得锁失败(比如 没能在过半Redis实例上获得到锁 或 获得锁的时间已经超过了 有效时间),client需要在所有Redis实例上解锁(不管是否加锁了都解锁).</p><h4 id="Redisson-对-RedLock-的实现"><a href="#Redisson-对-RedLock-的实现" class="headerlink" title="Redisson 对 RedLock 的实现"></a>Redisson 对 RedLock 的实现</h4><ol><li><p>使用api</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RLock redLock = redissonClient.getLock(<span class="string">"REDLOCK_KEY"</span>);</span><br><span class="line"><span class="comment">// 加锁.500ms获取不到锁则认为获取锁失败.锁的失效时间是 10s</span></span><br><span class="line"><span class="keyword">boolean</span> isLock = redLock.tryLock(<span class="number">500</span>, <span class="number">10000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">redLock.unlock();</span><br></pre></td></tr></table></figure></li><li><p>加锁时的lua逻辑</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RedissonLock.tryLockInnerAsync()方法</span></span><br><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">                <span class="comment">// 1.若 加锁的key(hash)不存在</span></span><br><span class="line">                <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span><br><span class="line">                    <span class="comment">// 通过 hset key uuid+threadId 1 来加锁</span></span><br><span class="line">                    <span class="string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                    <span class="comment">// 设置锁(hash)失效时间</span></span><br><span class="line">                    <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                    <span class="string">"return nil; "</span> +</span><br><span class="line">                <span class="string">"end; "</span> +</span><br><span class="line">                <span class="comment">// 2.若 加锁的key(hash)存在 且 uuid+threadId 也存在</span></span><br><span class="line">                <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span><br><span class="line">                    <span class="comment">// 重入计数加1</span></span><br><span class="line">                    <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                    <span class="comment">// 重新设置(hash)失效时间</span></span><br><span class="line">                    <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                    <span class="string">"return nil; "</span> +</span><br><span class="line">                <span class="string">"end; "</span> +</span><br><span class="line">                <span class="comment">// 3.返回锁(hash)的失效时间</span></span><br><span class="line">                <span class="string">"return redis.call('pttl', KEYS[1]);"</span>,</span><br><span class="line">                <span class="comment">// KEYS[1]锁key, ARGV[1]锁失效时间, ARGV[2] uuid+threadId</span></span><br><span class="line">                Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.加锁的hash不存在.创建hash,通过给 hash 的 key(uuid+threadId) 设置 value 为1.返回 nil表示加锁成功.<br>2.加锁的hash存在 且 key 也存在,表示当前线程重入的情况,重入计数加1.<br>3.走到这表示获取锁失败,返回锁的失效时间.</p><ol start="3"><li>解锁时的lua逻辑</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="comment">// 若锁key不存在,说明锁已释放.直接执行 publish 命令 发布释放锁消息 并返回 1</span></span><br><span class="line">            <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span><br><span class="line">                <span class="comment">// 向channel(即redisson_lock__channel:&#123;lockName&#125;)发送一条消息</span></span><br><span class="line">                <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span><br><span class="line">                <span class="string">"return 1; "</span> +</span><br><span class="line">            <span class="string">"end;"</span> +</span><br><span class="line">            <span class="comment">// 下面都是锁key存在的情况</span></span><br><span class="line">            <span class="comment">// 锁key存在但是 field(id+threadId) 不匹配,说明不是当前线程加的锁,不管,返回 nil</span></span><br><span class="line">            <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then "</span> +</span><br><span class="line">                <span class="string">"return nil;"</span> +</span><br><span class="line">            <span class="string">"end; "</span> +</span><br><span class="line">            <span class="comment">// 若锁key存在 且 field(id+threadId) 匹配,说明就是当前线程加的锁,重入计数减 1</span></span><br><span class="line">            <span class="string">"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); "</span> +</span><br><span class="line">            <span class="comment">// 重入计数减1后count&gt;0,说明没完全释放掉锁.重新设置失效时间,返回0</span></span><br><span class="line">            <span class="string">"if (counter &gt; 0) then "</span> +</span><br><span class="line">                <span class="string">"redis.call('pexpire', KEYS[1], ARGV[2]); "</span> +</span><br><span class="line">                <span class="string">"return 0; "</span> +</span><br><span class="line">            <span class="comment">// 重入计数减为0的情况,完全释放锁,删除key解锁,publish解锁消息,返回1</span></span><br><span class="line">            <span class="string">"else "</span> +</span><br><span class="line">                <span class="string">"redis.call('del', KEYS[1]); "</span> +</span><br><span class="line">                <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span><br><span class="line">                <span class="string">"return 1; "</span>+</span><br><span class="line">            <span class="string">"end; "</span> +</span><br><span class="line">            <span class="string">"return nil;"</span>,</span><br><span class="line">            <span class="comment">// KEYS[1]锁key, KEYS[2] channelName, ARGV[1]解锁消息 值为0, ARGV[2]锁失效时间, ARGV[3] id+threadId</span></span><br><span class="line">            Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.unlockMessage, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.若锁key不存在,说明锁已释放.直接执行 publish 命令 发布释放锁消息 并返回 1<br>2.锁key存在但是 field(id+threadId) 不匹配,说明不是当前线程加的锁,不管,返回 nil<br>3.若锁key存在 且 field(id+threadId) 匹配,说明就是当前线程加的锁,重入计数减 1<br>3.1.重入计数减1后count&gt;0,说明没完全释放掉锁.重新设置失效时间,返回0<br>3.2.重入计数减为0的情况,完全释放锁,删除key解锁,publish解锁消息,返回1</p><h1 id="see"><a href="#see" class="headerlink" title="@see"></a>@see</h1><p><a href="https://github.com/redisson/redisson/wiki/Redisson%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">Redisson项目官方介绍wiki</a></p><p><a href="http://www.redis.cn/topics/distlock.html" target="_blank" rel="noopener">Redis实现分布式锁官网</a></p><p><a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8#81-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81reentrant-lock" target="_blank" rel="noopener">Redisson实现分布式锁官方wiki</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis实现分布式锁&quot;&gt;&lt;a href=&quot;#Redis实现分布式锁&quot; class=&quot;headerlink&quot; title=&quot;Redis实现分布式锁&quot;&gt;&lt;/a&gt;Redis实现分布式锁&lt;/h1&gt;&lt;h2 id=&quot;要考虑的点&quot;&gt;&lt;a href=&quot;#要考虑的点&quot; class
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo心跳机制</title>
    <link href="http://yoursite.com/2019/12/15/01no/dubbo/dubbo07-heartbeat/"/>
    <id>http://yoursite.com/2019/12/15/01no/dubbo/dubbo07-heartbeat/</id>
    <published>2019-12-14T16:00:00.000Z</published>
    <updated>2020-05-24T14:12:21.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dubbo心跳机制"><a href="#Dubbo心跳机制" class="headerlink" title="Dubbo心跳机制"></a>Dubbo心跳机制</h1><p>Dubbo 默认客户端和服务端都会发送心跳报文,用来保持 TCP 长连接状态.</p><p>在客户端和服务端,Dubbo 都会开启一个线程 循环扫描 并 检测连接是否超时.</p><p>在服务端发现超时则会主动关闭客户端连接.</p><p>在客户端发现超时则会主动重新创建连接.</p><p>默认心跳检测时间是 60 秒.</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>provider 心跳默认是在 heartbeat(一分钟)内如果没有读消息或写消息,就会发送心跳请求消息,如果连着3次(180s)没有读消息,provider会关闭channel.</p><p>consumer 端的心跳默认是在 一分钟 内如果没有读消息或写消息,就会发送心跳请求消息,如果连着3次(三分钟)没有读消息,consumer会进行重连.</p><h2 id="开启定时任务"><a href="#开启定时任务" class="headerlink" title="开启定时任务"></a>开启定时任务</h2><p>provider 在启动 netty时,在 HeaderExchangeServer 的构造方法中,会通过 startHeatbeatTimer() 启动心跳定时任务.<br>consumer 在 HeaderExchangeClient 的构造方法里,同样通过 startHeatbeatTimer() 启动心跳定时任务.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHeatbeatTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 停止原有定时任务</span></span><br><span class="line">    stopHeartbeatTimer();</span><br><span class="line">    <span class="comment">// 发起新的定时任务</span></span><br><span class="line">    <span class="keyword">if</span> (heartbeat &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        heatbeatTimer = scheduled.scheduleWithFixedDelay(</span><br><span class="line">                <span class="keyword">new</span> HeartBeatTask(<span class="keyword">new</span> HeartBeatTask.ChannelProvider() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> Collections.unmodifiableCollection(HeaderExchangeServer.<span class="keyword">this</span>.getChannels());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, heartbeat, heartbeatTimeout),</span><br><span class="line">                heartbeat, heartbeat, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>HeartbeatHandler 会被串在请求和响应的处理链上.每当 received()收到消息时,会更新 ReadTimestamp,当 sent() 时 会更新 writeTimestamp.</p><h2 id="HeartBeatTask-逻辑"><a href="#HeartBeatTask-逻辑" class="headerlink" title="HeartBeatTask 逻辑"></a>HeartBeatTask 逻辑</h2><p>1.遍历所有Channel.在服务端遍历的是所有客户端连接,客户端遍历的是所有服务端连接.<br>2.已经 closed 的 channel 不管.<br>3.最后读写的时间,只要有一个超过心跳间隔(默认 heartbeat 是一分钟),就创建并发送心跳 request.<br>4.检测 最后读的时间,若超过心跳超时时间(默认 heartbeatTimeout 是三分钟).若是 client 侧会 reconnect 重连,若是 server 侧会关闭客户端连接.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Dubbo心跳机制&quot;&gt;&lt;a href=&quot;#Dubbo心跳机制&quot; class=&quot;headerlink&quot; title=&quot;Dubbo心跳机制&quot;&gt;&lt;/a&gt;Dubbo心跳机制&lt;/h1&gt;&lt;p&gt;Dubbo 默认客户端和服务端都会发送心跳报文,用来保持 TCP 长连接状态.&lt;/p
      
    
    </summary>
    
      <category term="Dubbo" scheme="http://yoursite.com/categories/Dubbo/"/>
    
    
      <category term="Dubbo" scheme="http://yoursite.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper Watcher机制</title>
    <link href="http://yoursite.com/2019/12/14/01no/zk/zk08_watcher/"/>
    <id>http://yoursite.com/2019/12/14/01no/zk/zk08_watcher/</id>
    <published>2019-12-13T16:00:00.000Z</published>
    <updated>2020-05-24T13:43:40.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="watcher流程"><a href="#watcher流程" class="headerlink" title="watcher流程"></a>watcher流程</h1><p>三个过程:<br>client 注册 Watcher<br>server 处理 Watcher<br>client 回调 Watcher</p><h2 id="client-注册-Watcher"><a href="#client-注册-Watcher" class="headerlink" title="client 注册 Watcher"></a>client 注册 Watcher</h2><p>zk client 可以通过 new ZooKeeper(),getData(),getChildren(), exist() 传入 watcher对象 来 注册 Watcher.</p><p>比如对于 <code>getData()时注册watcher的操作</code>.实际上 client 就是把 watcher 对象 存到 DataWatchRegistration 里,再创建 Packet,存入 outgoingQueue,等待 SendThread 线程取出来发给 server.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.创建ZooKeeper对象时注册Watcher</span><br><span class="line">- new ZooKeeper()传入Watcher,会回调Watcher.process()方法</span><br><span class="line">    - ZooKeeper中会创建ZKWatchManager</span><br><span class="line">    - watchManager.defaultWatcher &#x3D; watcher;初始化默认Watcher</span><br><span class="line">    - 解析connectString创建hostProvider</span><br><span class="line">    - 创建客户端连接管理类ClientCnxn</span><br><span class="line">    - 启动ClientCnxn线程</span><br><span class="line">        - ClientCnxn构造方法中创建sendThread和eventThread</span><br><span class="line">            EventThread负责处理Server返回的WatchedEvent,回调注册的客户端事件接口处理函数</span><br><span class="line">            SendThread为outgoing(传出)请求队列提供服务并生成心跳.它还会产生ReadThread</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.setData()</span><br><span class="line">- zk.setData(path, data, version);</span><br><span class="line">    - 创建RequestHeader,调用cnxn.submitRequest(h, request, response, null);</span><br><span class="line">        - clientCnxn.submitRequest()中:将Request等信息封装成packet,放入outgoingQueue队列中</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; sendThread逻辑</span><br><span class="line">- ClientCnxn.SendThread中</span><br><span class="line">    - run()逻辑</span><br><span class="line">        - 建立与server的连接</span><br><span class="line">        - 定时发送ping</span><br><span class="line">        - 委托给 clientCnxnSocket.doTransport()进行底层的nio传输</span><br><span class="line">            - ClientCnxnSocketNIO.doIO()中</span><br><span class="line">                从outgoingQueue取出packet</span><br><span class="line">            - p.createBB();&#x2F;&#x2F; 序列化</span><br><span class="line">            - sock.write(p.bb);&#x2F;&#x2F; 发送</span><br><span class="line">            - 从outgoingQueue队列中移除该发送的包</span><br><span class="line">            - pendingQueue.add(p);&#x2F;&#x2F; 将packet加入到pendingQueue队列</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.getData()时注册watcher</span><br><span class="line">- zk.getData(zooDataPath, watcher, stat);getData()时注册watcher</span><br><span class="line">    - wcb &#x3D; new DataWatchRegistration(watcher, clientPath); &#x2F;&#x2F; 注册 watcher到DataWatchRegistration中</span><br><span class="line">        - packet &#x3D; new Packet(h, r, request, response, watchRegistration);通过watchRegistration创建packet,存入outgoingQueue,等待发送</span><br></pre></td></tr></table></figure><h2 id="server-处理-Watcher"><a href="#server-处理-Watcher" class="headerlink" title="server 处理 Watcher"></a>server 处理 Watcher</h2><p>比如对于 getData()时注册watcher的处理:其实 server端就是在 FinalRequestProcessor 中将 Watcher(其实是NIOServerCnxn对象) 添加到 WatchManager 对象的 watchTable 和 watch2Paths 属性中.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- 2.Server处理Watcher</span><br><span class="line">    - 处理客户端发来的zk.getData()注册watcher的请求</span><br><span class="line">        - NIOServerCnxnFactory.run()有读写事件</span><br><span class="line">            - NIOServerCnxn.doIO()</span><br><span class="line">                - NIOServerCnxn.readPayload();&#x2F;&#x2F; 读取内容</span><br><span class="line">                    - NIOServerCnxn.readRequest()</span><br><span class="line">                        - ZooKeeperServer.processPacket()</span><br><span class="line">                            - ZooKeeperServer.submitRequest(si);&#x2F;&#x2F; 提交请求</span><br><span class="line">                                - touch(si.cnxn);&#x2F;&#x2F; 判断session是否存在或者已经超时</span><br><span class="line">                                - firstProcessor.processRequest(si);&#x2F;&#x2F; 处理请求</span><br><span class="line">                                    - Processor链处理...</span><br><span class="line">                                        - FinalRequestProcessor.processRequest()中</span><br><span class="line">                                            - case OpCode.getData:&#x2F;&#x2F; 对于获取数据请求,若有watch会注册</span><br><span class="line">                                                - dataWatches.addWatch(path, watcher);&#x2F;&#x2F; 若有watcher的话则注册watcher,此时watcher为NIOServerCnxn.将Watcher添加到WatchManager对象的watchTable和watch2Paths属性中</span><br></pre></td></tr></table></figure></p><p>当server端收到了client端的setData()请求,由于引起了数据变更,会触发  getData()时注册watcher. 其实就是从上面 getData() 时存入的 watchTable 里查出来 watchers 并移除(只触发一次),调用 watcher.process()方法,也就是 NIOServerCnxn.process() 发送给 客户端 Watcher事件.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 3.Server触发Watcher</span><br><span class="line">    - 处理client发来的zk.setData()请求</span><br><span class="line">        - FinalRequestProcessor.processRequest()中</span><br><span class="line">            - rc &#x3D; zks.processTxn(hdr, txn);&#x2F;&#x2F; 处理事务,应用到 dataTree上</span><br><span class="line">                - DataTree.setData()中,有watcher时会触发watcher</span><br><span class="line">                    - dataWatches.triggerWatch(path, EventType.NodeDataChanged); &#x2F;&#x2F; setData()时会导致数据变更,若有watcher会触发watcher</span><br><span class="line">                        - watchers &#x3D; watchTable.remove(path); &#x2F;&#x2F; 获取该path对应的watchers,watchers只触发一次就移除</span><br><span class="line">                        - w.process(e);&#x2F;&#x2F; 进行watcher事件处理,传入WatchedEvent,此时的w是NioServerCnxn对象</span><br><span class="line">                            - NIOServerCnxn.process()中,创建响应头,xid&#x3D;-1代表watcher事件.将WatchedEvent对象转换为WatcherEvent,用于网络传输,响应客户端</span><br></pre></td></tr></table></figure></p><h2 id="client-回调-Watcher"><a href="#client-回调-Watcher" class="headerlink" title="client 回调 Watcher"></a>client 回调 Watcher</h2><p>client端 通过 SendThread.readResponse() 接收服务端响应.</p><p>根据 replyHdr.xid 判断是 Watcher事件.</p><p>将 来自服务端的响应,反序列成 WatcherEvent 对象,WatcherEvent 的信息里只包含 type,state,path 信息.<br><img src="https://gitee.com/flyingzc/MyImg/raw/master/img/zk/client收到的watcher信息.png" alt="client端收到的server端的watcher信息"></p><p>然后再将 WatcherEvent 对象 转成 WatchedEvent 对象.<br><img src="https://gitee.com/flyingzc/MyImg/raw/master/img/zk/client通过watcher创建WatchedEvent对象.png" alt="根据watcher信息创建的WatchedEvent对象"></p><p>从 ZKWatchManager.dataWatches 中 取出 path 对应的 watcher 并移除(只触发一次),连同 WatchedEvent 创建WatcherSetEventPair 对象.入 waitingEvents 队列,交给 eventThread 线程处理.</p><p>eventThread线程 从 waitingEvents 队列里取出对应的 watcher,调用 watcher.process() 处理.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- 4.Client回调Watcher</span><br><span class="line">    - SendThread.readResponse()接收服务端响应</span><br><span class="line">        - 根据replyHdr.getXid() &#x3D;&#x3D; -1 判断是Watcher通知,反序列化出WatcherEvent对象</span><br><span class="line">        - eventThread.queueEvent(we);&#x2F;&#x2F; 将Watcher事件 入事件队列,交给EventThread处理</span><br><span class="line">            - watcher.materialize()根据watcher的事件类型进行不同的处理</span><br><span class="line">                - 比如NodeDataChanged和NodeCreated事件</span><br><span class="line">                - 1.从 ZKWatchManager.dataWatches 中移除 clientPath 对应的 watchers(相当于只能触发一次),并将这些移除的 watchers 添加到 result 中返回</span><br><span class="line">            - 通过watcher和event创建WatcherSetEventPair</span><br><span class="line">            - waitingEvents.add(pair);&#x2F;&#x2F; 将WatcherSetEventPair对象入waitingEvents这个LinkedBlockingQueue中(保证watcher顺序)</span><br><span class="line">    - EventThread.run()中</span><br><span class="line">        - 从waitingEvents中取出event,调processEvent(event)</span><br><span class="line">            - processEvent(event)中</span><br><span class="line">                - event中包含实际的watcher对象,直接回调watcher.process()即可</span><br></pre></td></tr></table></figure><h1 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Watcher</span><br><span class="line">WatchedEvent</span><br><span class="line"></span><br><span class="line">ZooKeeper</span><br><span class="line">ZKWatchManager</span><br><span class="line"></span><br><span class="line">ClientWatchManager</span><br><span class="line"></span><br><span class="line">WatchRegistration</span><br><span class="line">    ChildWatchRegistration</span><br><span class="line">    DataWatchRegistration</span><br><span class="line">    ExistsWatchRegistration</span><br><span class="line"></span><br><span class="line">ClientCnxn</span><br><span class="line">Packet</span><br></pre></td></tr></table></figure><h2 id="Watcher接口"><a href="#Watcher接口" class="headerlink" title="Watcher接口"></a>Watcher接口</h2><p>Watcher 接口中包含:<br>1.Event 接口,用于定义<code>事件所代表的状态</code><br>Event 接口中包含 KeeperState(<code>事件发生时zk的状态</code>) 和 EventType(事件类型)两个枚举类<br>2.process() 抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.zookeeper;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 表示事件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@InterfaceAudience</span>.Public</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 事件发生时Zookeeper的状态</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">@InterfaceAudience</span>.Public</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">enum</span> KeeperState &#123;</span><br><span class="line">            <span class="meta">@Deprecated</span></span><br><span class="line">            Unknown(-<span class="number">1</span>),<span class="comment">// 未知状态.不再使用,服务器不会产生此状态</span></span><br><span class="line"></span><br><span class="line">            Disconnected(<span class="number">0</span>),<span class="comment">// 断开</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Deprecated</span></span><br><span class="line">            NoSyncConnected(<span class="number">1</span>),<span class="comment">// 未同步连接.不再使用,服务器不会产生此状态</span></span><br><span class="line"></span><br><span class="line">            SyncConnected(<span class="number">3</span>),<span class="comment">// 同步连接状态</span></span><br><span class="line"></span><br><span class="line">            AuthFailed(<span class="number">4</span>),<span class="comment">// 认证失败状态</span></span><br><span class="line"></span><br><span class="line">            ConnectedReadOnly(<span class="number">5</span>),<span class="comment">// 只读连接状态</span></span><br><span class="line"></span><br><span class="line">            SaslAuthenticated(<span class="number">6</span>),<span class="comment">// SASL认证通过状态</span></span><br><span class="line"></span><br><span class="line">            Expired(-<span class="number">112</span>);<span class="comment">// 过期状态</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 事件类型</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">enum</span> EventType &#123;</span><br><span class="line">            None(-<span class="number">1</span>),<span class="comment">// 无</span></span><br><span class="line">            NodeCreated(<span class="number">1</span>),<span class="comment">// 节点创建</span></span><br><span class="line">            NodeDeleted(<span class="number">2</span>),<span class="comment">// 节点删除</span></span><br><span class="line">            NodeDataChanged(<span class="number">3</span>),<span class="comment">// 节点数据变化</span></span><br><span class="line">            NodeChildrenChanged(<span class="number">4</span>);<span class="comment">// 节点的子节点变化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回调方法-process"><a href="#回调方法-process" class="headerlink" title="回调方法 process()"></a>回调方法 process()</h2><p>zk server 向 client 发送一个 watcher 通知时,会回调对应的 process() 方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span></span>;</span><br></pre></td></tr></table></figure></p><h2 id="WatchedEvent"><a href="#WatchedEvent" class="headerlink" title="WatchedEvent"></a>WatchedEvent</h2><p>process()方法的参数 WatchedEvent,zk server会将watcher事件通过 WatchedEvent 对象 传递给 client,WatchedEvent 包含了事件的一些属性:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WatchedEvent属性</span><br><span class="line">-keeperState: KeeperState <span class="comment">// 通知状态</span></span><br><span class="line">-eventType: EventType <span class="comment">// 事件类型</span></span><br><span class="line">-path: String <span class="comment">// 对应的path</span></span><br></pre></td></tr></table></figure></p><h2 id="WatcherEvent"><a href="#WatcherEvent" class="headerlink" title="WatcherEvent"></a>WatcherEvent</h2><p>WatcherEvent 用于网络传输.</p><p>zk server 在生成 WatchedEvent 事件后,通过 getwrapper() 将 WatchedEvent 包装成 可序列化的 WatcherEvent事件,用于网络传输.</p><p>zk client 接收到 server 的 WatcherEvent 对象后,会将 WatcherEvent 反序列化成 WatchedEvent 事件,传给 process() 方法.</p><h2 id="ServerCnxn"><a href="#ServerCnxn" class="headerlink" title="ServerCnxn"></a>ServerCnxn</h2><p>ServerCnxn 实现了 Watcher 接口</p><h2 id="WatchManager"><a href="#WatchManager" class="headerlink" title="WatchManager"></a>WatchManager</h2><p>WatchManager 是 ZooKeeper 服务端 Watcher 的管理者,包含 watchTable 和 watch2Paths.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;watcher流程&quot;&gt;&lt;a href=&quot;#watcher流程&quot; class=&quot;headerlink&quot; title=&quot;watcher流程&quot;&gt;&lt;/a&gt;watcher流程&lt;/h1&gt;&lt;p&gt;三个过程:&lt;br&gt;client 注册 Watcher&lt;br&gt;server 处理 Wa
      
    
    </summary>
    
      <category term="Zookeeper" scheme="http://yoursite.com/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="http://yoursite.com/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Hotspot编译</title>
    <link href="http://yoursite.com/2019/12/12/01no/hotspot/hotspot01-compile/"/>
    <id>http://yoursite.com/2019/12/12/01no/hotspot/hotspot01-compile/</id>
    <published>2019-12-11T16:00:00.000Z</published>
    <updated>2020-03-14T03:51:58.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hotspot8编译"><a href="#hotspot8编译" class="headerlink" title="hotspot8编译"></a>hotspot8编译</h1><p><a href="https://www.cnblogs.com/simoncook/p/11198117.html" target="_blank" rel="noopener">参照xiaguang的博客</a>,帮我踩了很多坑,虽然编译过程中还是遇到了一点小问题.</p><h2 id="修改-ubuntu18-adp-源"><a href="#修改-ubuntu18-adp-源" class="headerlink" title="修改 ubuntu18 adp 源"></a>修改 ubuntu18 adp 源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br></pre></td></tr></table></figure><p>最好搜索一下最新的国内源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse</span><br><span class="line">deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure><h2 id="安装相关依赖"><a href="#安装相关依赖" class="headerlink" title="安装相关依赖"></a>安装相关依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-4.8</span><br><span class="line">sudo apt-get install g++-4.8</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install  libxext-dev libxrender-dev libxtst-dev libxt-dev</span><br><span class="line">sudo apt-get install libcups2-dev</span><br><span class="line">sudo apt-get install libfreetype6-dev</span><br><span class="line">sudo apt-get install libasound2-dev</span><br></pre></td></tr></table></figure><h2 id="clone-hostspot-代码"><a href="#clone-hostspot-代码" class="headerlink" title="clone hostspot 代码"></a>clone hostspot 代码</h2><p>原文是通过 <code>hg clone http://hg.openjdk.java.net/jdk8/jdk8</code> 下载,但是官网速度太慢了.fan了也很慢.</p><p>后来找了个github上的镜像,总是下载一半就出问题:<br><a href="https://github.com/unofficial-openjdk/openjdk" target="_blank" rel="noopener">https://github.com/unofficial-openjdk/openjdk</a></p><p>最后用gitee里的这个镜像,速度很快,tag 也比较全<br><a href="https://gitee.com/solie/openjdk.git" target="_blank" rel="noopener">https://gitee.com/solie/openjdk.git</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; clone</span><br><span class="line">git clone https:&#x2F;&#x2F;gitee.com&#x2F;solie&#x2F;openjdk.git</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 切分支</span><br><span class="line">git checkout jdk8-b120 </span><br><span class="line"></span><br><span class="line">git checkout -b jdk8-b120-zc jdk8-b120</span><br></pre></td></tr></table></figure><p>代码路径<br>/home/flyingzc/java/workspace/01opensource/openjdk</p><h2 id="下载并编译-make-3-82"><a href="#下载并编译-make-3-82" class="headerlink" title="下载并编译 make 3.82"></a>下载并编译 make 3.82</h2><p>1.下载地址: <a href="ftp://ftp.gnu.org/gnu/make/make-3.82.tar.gz">ftp://ftp.gnu.org/gnu/make/make-3.82.tar.gz</a></p><p>2.解压<br>flyingzc@ubuntu:~/java/downloads$ tar -zxvf make-3.82.tar.gz -C .</p><p>3.vim glob/glob.c</p><p>将 第 211行, 232行 注释掉,注释后如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#&#x2F;&#x2F; #if !defined __alloca &amp;&amp; !defined __GNU_LIBRARY__</span><br><span class="line">#&#x2F;&#x2F; #endif</span><br></pre></td></tr></table></figure></p><h2 id="准备编译-make3-82"><a href="#准备编译-make3-82" class="headerlink" title="准备编译 make3.82"></a>准备编译 make3.82</h2><p>chmod +x configure<br>./configure<br>make<br>./make –version<br><img src="../../assets/hotspot/001make-success.png" alt="make编译成功"></p><h2 id="将系统的默认-make-链接成-3-82-版本"><a href="#将系统的默认-make-链接成-3-82-版本" class="headerlink" title="将系统的默认 make 链接成 3.82 版本"></a>将系统的默认 make 链接成 3.82 版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line"></span><br><span class="line">sudo ln -s  &#x2F;home&#x2F;flyingzc&#x2F;java&#x2F;soft&#x2F;make-3.82&#x2F;make make-3.82</span><br><span class="line"></span><br><span class="line">sudo rm make</span><br><span class="line"></span><br><span class="line">sudo ln -s make-3.82 make</span><br><span class="line"></span><br><span class="line">make --version</span><br><span class="line">输出: GNU Make 3.82</span><br></pre></td></tr></table></figure><h2 id="确认-gcc-和-g-是4-8版本"><a href="#确认-gcc-和-g-是4-8版本" class="headerlink" title="确认 gcc 和 g++ 是4.8版本"></a>确认 gcc 和 g++ 是4.8版本</h2><h3 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;bin</span><br><span class="line">sudo rm gcc</span><br><span class="line">sudo ln -s gcc-4.8 gcc</span><br></pre></td></tr></table></figure><h3 id="g"><a href="#g" class="headerlink" title="g++"></a>g++</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;bin</span><br><span class="line">sudo rm g++</span><br><span class="line">sudo ln -s g++-4.8 g++</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flyingzc@ubuntu:&#x2F;usr&#x2F;bin$ gcc --version</span><br><span class="line">gcc (Ubuntu 4.8.5-4ubuntu8) 4.8.5</span><br><span class="line">Copyright (C) 2015 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line"></span><br><span class="line">flyingzc@ubuntu:&#x2F;usr&#x2F;bin$ g++ --version</span><br><span class="line">g++ (Ubuntu 4.8.5-4ubuntu8) 4.8.5</span><br><span class="line">Copyright (C) 2015 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br></pre></td></tr></table></figure></p><h2 id="修改支持的os版本检查"><a href="#修改支持的os版本检查" class="headerlink" title="修改支持的os版本检查"></a>修改支持的os版本检查</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查看内核版本</span><br><span class="line">uname -a</span><br><span class="line">Linux ubuntu 5.0.0-37-generic #40~18.04.1-Ubuntu SMP Thu Nov 14 12:06:39 UTC 2019 x86_64 x86_64 x86_64 GNU&#x2F;Linux</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hotspot&#x2F;make&#x2F;linux&#x2F;Makefile</span><br><span class="line">修改 SUPPORTED_OS_VERSION &#x3D;... 加上4%,不然4.x的内核不支持.我的ubuntu内核是5.x,需要加上 5%</span><br></pre></td></tr></table></figure><h2 id="如果存在build目录则删除"><a href="#如果存在build目录则删除" class="headerlink" title="如果存在build目录则删除"></a>如果存在build目录则删除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm -rf build&#x2F;</span><br><span class="line"></span><br><span class="line">chmod +x configure</span><br><span class="line"></span><br><span class="line">.&#x2F;configure --with-debug-level&#x3D;slowdebug</span><br></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup make all &amp; tail -f nohup.out</span><br></pre></td></tr></table></figure><h2 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Running nasgen</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.VerifyError: class jdk.nashorn.internal.objects.ScriptFunctionImpl overrides final method setPrototype.(Ljava&#x2F;lang&#x2F;Object;)V</span><br><span class="line">at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:756)</span><br><span class="line">at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)</span><br><span class="line">at java.net.URLClassLoader.defineClass(URLClassLoader.java:468)</span><br><span class="line">at java.net.URLClassLoader.access$100(URLClassLoader.java:74)</span><br><span class="line">at java.net.URLClassLoader$1.run(URLClassLoader.java:369)</span><br><span class="line">at java.net.URLClassLoader$1.run(URLClassLoader.java:363)</span><br><span class="line">at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">at java.net.URLClassLoader.findClass(URLClassLoader.java:362)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:418)</span><br><span class="line">at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:355)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:351)</span><br><span class="line">at jdk.nashorn.internal.tools.nasgen.StringConstants.&lt;clinit&gt;(StringConstants.java:85)</span><br><span class="line">at jdk.nashorn.internal.tools.nasgen.MemberInfo.verify(MemberInfo.java:250)</span><br><span class="line">at jdk.nashorn.internal.tools.nasgen.ScriptClassInfo.verify(ScriptClassInfo.java:227)</span><br><span class="line">at jdk.nashorn.internal.tools.nasgen.Main.process(Main.java:108)</span><br><span class="line">at jdk.nashorn.internal.tools.nasgen.Main.processAll(Main.java:88)</span><br><span class="line">at jdk.nashorn.internal.tools.nasgen.Main.main(Main.java:62)</span><br><span class="line">make[1]: *** [&#x2F;home&#x2F;flyingzc&#x2F;java&#x2F;workspace&#x2F;01opensource&#x2F;openjdk&#x2F;build&#x2F;linux-x86_64-normal-server-slowdebug&#x2F;nashorn&#x2F;classes&#x2F;_the.nasgen.run] Error 1</span><br><span class="line">make: *** [nashorn-only] Error 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改：vim nashorn&#x2F;make&#x2F;BuildNashorn.gmk</span><br><span class="line">第80行 -cp &quot;$(NASHORN_OUTPUTDIR)&#x2F;nasgen_classes$(PATH_SEP) </span><br><span class="line">第80行将原来的 -cp 修改为 -Xbootclasspath&#x2F;p:</span><br></pre></td></tr></table></figure><p><a href="https://juejin.im/entry/5a6c36af6fb9a01cb64f05b8" target="_blank" rel="noopener">问题的解决方案来自这里</a></p><h2 id="编译成功输出的信息"><a href="#编译成功输出的信息" class="headerlink" title="编译成功输出的信息"></a>编译成功输出的信息</h2><p><img src="../../assets/hotspot/002compile-success.png" alt="编译成功"></p><h1 id="解压调试符号包"><a href="#解压调试符号包" class="headerlink" title="解压调试符号包"></a>解压调试符号包</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openjdk&#x2F;build&#x2F;linux-x86_64-normal-server-slowdebug&#x2F;jdk&#x2F;lib&#x2F;amd64&#x2F;server 目录下</span><br><span class="line">unzip libjvm.diz</span><br></pre></td></tr></table></figure><p>解压出来的是 libjvm.debuginfo 调试信息文件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hotspot8编译&quot;&gt;&lt;a href=&quot;#hotspot8编译&quot; class=&quot;headerlink&quot; title=&quot;hotspot8编译&quot;&gt;&lt;/a&gt;hotspot8编译&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/simon
      
    
    </summary>
    
      <category term="Hotspot" scheme="http://yoursite.com/categories/Hotspot/"/>
    
    
      <category term="Hotspot" scheme="http://yoursite.com/tags/Hotspot/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper实现分布式锁</title>
    <link href="http://yoursite.com/2019/12/12/01no/zk/zk20-lock/"/>
    <id>http://yoursite.com/2019/12/12/01no/zk/zk20-lock/</id>
    <published>2019-12-11T16:00:00.000Z</published>
    <updated>2020-05-24T13:44:02.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zk实现分布式锁"><a href="#zk实现分布式锁" class="headerlink" title="zk实现分布式锁"></a>zk实现分布式锁</h1><h2 id="zk实现分布式锁的两种方式"><a href="#zk实现分布式锁的两种方式" class="headerlink" title="zk实现分布式锁的两种方式"></a>zk实现分布式锁的两种方式</h2><p>如果要自己通过 zookeeper 的原生 api 实现一个分布式独占锁的话,有两种方式:</p><h3 id="方式1-创建临时节点-创建失败的client注册watcher"><a href="#方式1-创建临时节点-创建失败的client注册watcher" class="headerlink" title="方式1: 创建临时节点,创建失败的client注册watcher"></a>方式1: 创建临时节点,创建失败的client注册watcher</h3><p>所有需要获取锁的 client 都尝试到 zk 上创建同一个临时节点.创建成功则表示成功获取锁;若创建失败,则对这个节点注册 watcher.</p><p>若获得锁的 client 释放锁(自己 delete 掉节点) 或 宕机(zk 会自动移除掉该临时节点),</p><p>其他 client 会收到 watcher 通知,再尝试去抢锁.</p><p>这种方式的问题: 很明显竞争很大.在节点失效瞬间,如果争锁的 client 较多,会有大量 client 接收 watcher 通知.</p><h3 id="方式2-基于临时顺序节点"><a href="#方式2-基于临时顺序节点" class="headerlink" title="方式2: 基于临时顺序节点"></a>方式2: 基于临时顺序节点</h3><p>创建锁<br>1.每个 client 都在 zk 同一个父节点上创建一个 临时顺序节点<br>2.然后每个 client 获取到父节点下的所有节点并排序,判断自己是否是顺序最小的那个节点<br>2.1.如果是,加锁成功<br>2.2.如果不是,加锁失败.注册 watcher,只用监听自己之前的那个节点即可.</p><p>释放锁<br>1.client1 删除自己的临时顺序节点<br>2.后面一个 client2 通过 watcher 感知到节点已经删除,自己是当前最小的那个节点,则获取锁.<br>这种方式,明显 watcher 压力会小很多.不会出现大量竞争.</p><h2 id="curator-实现的分布式锁"><a href="#curator-实现的分布式锁" class="headerlink" title="curator 实现的分布式锁"></a>curator 实现的分布式锁</h2><p>很明显之前的思路只是简单的实现.有很多其他的东西没有考虑,比如: 可重入.<br>看一下 curator 实现的时候,对 zookeeper 分布式锁做了哪些处理.</p><p>主要看 InterProcessMutex: 分布式可重入排它锁 的实现.</p><p>首先 curator 就是使用上面的方式2: 基于临时顺序节点 实现的分布式锁.</p><p>curator创建分布式锁的代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(client, lock_path);</span><br><span class="line">lock.acquire(); <span class="comment">// 获取锁</span></span><br><span class="line">lock.release(); <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure></p><h3 id="获取锁流程"><a href="#获取锁流程" class="headerlink" title="获取锁流程"></a>获取锁流程</h3><p>简单来说就是获取锁时,先处理是否需要重入.然后创建临时顺序节点.然后获取父节点的所有子节点并排序.若当前节点排在最前面获取锁,否则对前一个节点注册watcher并wait()等待被唤醒,如果传入超时时间,就wait(millisToWait).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- 获取锁</span><br><span class="line">    - lock.acquire()一直阻塞直到获取到锁,支持重入.</span><br><span class="line">        - InterProcessMutex.internalLock(-1, null)</span><br><span class="line">        - 1.获取当前线程对象</span><br><span class="line">        - 2.ConcurrentMap&lt;Thread, LockData&gt;类型的threadData对象,key是线程对象.value是LockData类型的对象.lockData.lockCount属性用于保存当前线程的重入计数.如果是当前线程重入,则计数加1</span><br><span class="line">        - 3.尝试加锁internals.attemptLock(time, unit, getLockNodeBytes())</span><br><span class="line">            - LockInternals.attemptLock()中</span><br><span class="line">            - 1.循环</span><br><span class="line">            - 1.1.driver.createsTheLock()用这个&#x2F;curator_recipes_lock_path&#x2F;lock-前缀创建临时顺序节点</span><br><span class="line">            - 1.2.hasTheLock &#x3D; internalLockLoop(startMillis, millisToWait, ourPath);</span><br><span class="line">                - internalLockLoop()中</span><br><span class="line">                - 1.只要没获取到锁,循环</span><br><span class="line">                - 1.1.getSortedChildren()比如_c_62f35524-d650-4efc-a121-ea6611b47285-lock-0000000066按照lock-后面的数字排序</span><br><span class="line">                - 1.2.predicateResults &#x3D; driver.getsTheLock()返回是否能拿到锁还是注册watcher</span><br><span class="line">                    - driver.getsTheLock()逻辑</span><br><span class="line">                    - 1.获取当前临时节点在childern里的index并校验</span><br><span class="line">                    - 2.如果是第0个节点getsTheLock设为true表示能获取锁.否则获取当前临时节点的前一个节点设置到pathToWatch里,表示要注册watcher.</span><br><span class="line">                    - 3.封装成PredicateResults结果返回</span><br><span class="line">                - 1.3.若1.2中返回能拿到锁,haveTheLock置为true标识拿到锁,跳出循环.否则加锁,对前一个节点注册watcher并wait()等待被唤醒.</span><br></pre></td></tr></table></figure></p><h3 id="释放锁流程"><a href="#释放锁流程" class="headerlink" title="释放锁流程"></a>释放锁流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 释放锁</span><br><span class="line">    - lock.release();</span><br><span class="line">    - 1.从threadData中获取当前线程的lockData.lockCount重入计数并减1</span><br><span class="line">    - 2.当1中重入计数减少到0则internals.releaseLock(lockData.lockPath)释放锁</span><br><span class="line">        - 删除节点deleteOurPath(lockPath)</span><br><span class="line">    - 3.从threadData中,删除当前线程的缓存threadData.remove(currentThread)</span><br></pre></td></tr></table></figure><h3 id="watcher唤醒"><a href="#watcher唤醒" class="headerlink" title="watcher唤醒"></a>watcher唤醒</h3><p>watcher在 获取锁流程 时候注册上去的.在锁释放的时候,会触发watcher逻辑,唤醒wait的线程.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册watcher</span></span><br><span class="line">client.getData().usingWatcher(watcher).forPath(previousSequencePath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// watcher实例如下</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Watcher watcher = <span class="keyword">new</span> Watcher()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 此处会唤醒wait()的线程</span></span><br><span class="line">        notifyFromWatcher();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;zk实现分布式锁&quot;&gt;&lt;a href=&quot;#zk实现分布式锁&quot; class=&quot;headerlink&quot; title=&quot;zk实现分布式锁&quot;&gt;&lt;/a&gt;zk实现分布式锁&lt;/h1&gt;&lt;h2 id=&quot;zk实现分布式锁的两种方式&quot;&gt;&lt;a href=&quot;#zk实现分布式锁的两种方式&quot; c
      
    
    </summary>
    
      <category term="Zookeeper" scheme="http://yoursite.com/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="http://yoursite.com/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo Provider处理请求</title>
    <link href="http://yoursite.com/2019/12/05/01no/dubbo/dubbo06-provider/"/>
    <id>http://yoursite.com/2019/12/05/01no/dubbo/dubbo06-provider/</id>
    <published>2019-12-04T16:00:00.000Z</published>
    <updated>2020-05-24T14:13:57.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务端接收并响应请求流程"><a href="#服务端接收并响应请求流程" class="headerlink" title="服务端接收并响应请求流程"></a>服务端接收并响应请求流程</h1><h2 id="provider处理请求流程"><a href="#provider处理请求流程" class="headerlink" title="provider处理请求流程"></a>provider处理请求流程</h2><p><img src="../../assets/2019-12-15-16-19-04.png" alt="provider decode"></p><p><img src="https://gitee.com/flyingzc/MyImg/raw/master/img/dubbo/provider接收线程.png" alt="provider接收线程"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- NettyServerWorker线程接收请求</span><br><span class="line">    - ByteToMessageDecoder.channelRead()</span><br><span class="line">        - ByteToMessageDecoder.callDecode()</span><br><span class="line">            - NettyCodecAdapter.InternalDecoder.decode()</span><br><span class="line">                - DubboCountCodec.decode()解码</span><br><span class="line">        - fireChannelRead(ctx, out, size)</span><br><span class="line">            - NettyServerHandler.channelRead()</span><br><span class="line">                - AbstractPeer.received()</span><br><span class="line">                    - MultiMessageHandler.received()</span><br><span class="line">                        - HeartbeatHandler.received()</span><br><span class="line">                            - AllChannelHandler.received()</span><br><span class="line">                                - cexecutor.execute(new ChannelEventRunnable())&#x2F;&#x2F; 请求派发到线程池处理,逻辑在ChannelEventRunnable.run()里</span><br></pre></td></tr></table></figure><p>AllChannelHandler.received()方法中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));</span><br></pre></td></tr></table></figure><br>会将请求交给 ChannelEventRunnable 进行处理,后续在 DubboServerHandler 线程池里的调用逻辑:</p><p><img src="https://gitee.com/flyingzc/MyImg/raw/master/img/dubbo/provider处理请求流程调用链.png" alt="provider处理请求流程调用链"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- provider处理请求流程</span><br><span class="line">- ChannelEventRunnable.run()通道事件,判断RECEIVED事件进行处理</span><br><span class="line">    - DecodeHandler.received()解码处理器</span><br><span class="line">        - HeaderExchangeHandler.received()基于消息头的处理</span><br><span class="line">            - 1.HeaderExchangeHandler.handleRequest()处理请求</span><br><span class="line">                - DubboProtocol.requestHandler.reply()</span><br><span class="line">                - 1.从exporterMap(服务暴露时创建的)中获取对应的invoker对象</span><br><span class="line">                - 2.invoker.invoke()</span><br><span class="line">                    - 经过各个filter.invoke()</span><br><span class="line">                    - InvokerWrapper.invoke()</span><br><span class="line">                        - AbstractProxyInvoker.invoke()中</span><br><span class="line">                        - 1.doInvoke(methodName,paramType, arguments)</span><br><span class="line">                            - JavassistProxyFactory.doInvoke()</span><br><span class="line">                                - com.alibaba.dubbo.demo.provider.DemoServiceImpl.sayHello()</span><br><span class="line">                                    - DemoServiceImpl.sayHello()</span><br><span class="line">                        - 2.new RpcResult()上一步的返回结果包装成RpcResult返回,后续处理原路返回</span><br><span class="line">            - 2.channel.send(response)响应请求</span><br><span class="line">            - &#x2F;&#x2F; 参见 provider响应请求流程</span><br></pre></td></tr></table></figure><h2 id="provider请求响应流程"><a href="#provider请求响应流程" class="headerlink" title="provider请求响应流程"></a>provider请求响应流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- provider响应请求流程</span><br><span class="line">    - 各个filter的后续处理</span><br><span class="line">        - HeaderExchangeHandler.received()中处理请求时走handleRequest(),请求处理完后通过channel.send(response)响应</span><br><span class="line">            - AbstractPeer.send()</span><br><span class="line">                - netty4&#x2F;NettyChannel.send()</span><br><span class="line">                </span><br><span class="line">- 响应线程NettyServerWorker-3-1</span><br><span class="line">    - Thread.run()</span><br><span class="line">        - DefaultThreadFactory$DefaultRunnableDecorator.run()</span><br><span class="line">            - SingleThreadEventExecutor.run()</span><br><span class="line">                - NioEventLoop.run()</span><br><span class="line">                    - SingleThreadEventExecutor.runAllTasks()</span><br><span class="line">                    - &#x2F;&#x2F; ...</span><br><span class="line">                        - AbstractChannelHandlerContext$WriteAndFlushTask.write()</span><br><span class="line">                            - NettyServerHandler.write()</span><br><span class="line">                                - AbstractPeer.sent()</span><br><span class="line">                                    - AbstractChannelHandlerDelegate.sent()</span><br><span class="line">                                        - HeartbeatHandler.sent()设置最后的写时间</span><br><span class="line">                                            - WrappedChannelHandler.sent()</span><br><span class="line">                                                - AbstractChannelHandlerDelegate.sent()</span><br><span class="line">                                                    - HeaderExchangeHandler.sent()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;服务端接收并响应请求流程&quot;&gt;&lt;a href=&quot;#服务端接收并响应请求流程&quot; class=&quot;headerlink&quot; title=&quot;服务端接收并响应请求流程&quot;&gt;&lt;/a&gt;服务端接收并响应请求流程&lt;/h1&gt;&lt;h2 id=&quot;provider处理请求流程&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="Dubbo" scheme="http://yoursite.com/categories/Dubbo/"/>
    
    
      <category term="Dubbo" scheme="http://yoursite.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo Cluster</title>
    <link href="http://yoursite.com/2019/12/04/01no/dubbo/dubbo05-cluster/"/>
    <id>http://yoursite.com/2019/12/04/01no/dubbo/dubbo05-cluster/</id>
    <published>2019-12-03T16:00:00.000Z</published>
    <updated>2020-05-24T14:11:01.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cluster"><a href="#cluster" class="headerlink" title="cluster"></a>cluster</h1><p>Cluster 将 Directory 中的多个 Invoker 伪装成一个 Invoker,对上层透明,伪装过程包含了容错逻辑,调用失败后,重试另一个.</p><p>集群模块处于服务提供者和消费者之间,对于服务消费者来说,集群可向其屏蔽服务提供者集群的情况,使其能够专心进行远程调用.</p><p>cluster 继承结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Cluster(com.alibaba.dubbo.rpc.cluster)</span><br><span class="line">    MergeableCluster(com.alibaba.dubbo.rpc.cluster.support)</span><br><span class="line">    FailfastCluster(com.alibaba.dubbo.rpc.cluster.support)</span><br><span class="line">    MockClusterWrapper(com.alibaba.dubbo.rpc.cluster.support.wrapper)</span><br><span class="line">    FailsafeCluster(com.alibaba.dubbo.rpc.cluster.support)</span><br><span class="line">    ForkingCluster(com.alibaba.dubbo.rpc.cluster.support)</span><br><span class="line">    AvailableCluster(com.alibaba.dubbo.rpc.cluster.support)</span><br><span class="line">    FailbackCluster(com.alibaba.dubbo.rpc.cluster.support)</span><br><span class="line">    FailoverCluster(com.alibaba.dubbo.rpc.cluster.support)</span><br><span class="line">    BroadcastCluster(com.alibaba.dubbo.rpc.cluster.support)</span><br></pre></td></tr></table></figure></p><p>这些 Cluster 实现类里均实现了 join() 方法,用于创建其对应的 ClusterInvoker.</p><h1 id="Invoker接口"><a href="#Invoker接口" class="headerlink" title="Invoker接口"></a>Invoker接口</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Invoker(com.alibaba.dubbo.rpc)</span><br><span class="line">    ProviderInvokerWrapper(com.alibaba.dubbo.registry.support)</span><br><span class="line">    MockClusterInvoker(com.alibaba.dubbo.rpc.cluster.support.wrapper)</span><br><span class="line">    AbstractProxyInvoker(com.alibaba.dubbo.rpc.proxy)</span><br><span class="line">    ListenerInvokerWrapper(com.alibaba.dubbo.rpc.listener)</span><br><span class="line">    DelegateInvoker(com.alibaba.dubbo.rpc.support)</span><br><span class="line">    InvokerWrapper(com.alibaba.dubbo.rpc.protocol)</span><br><span class="line">    AbstractClusterInvoker(com.alibaba.dubbo.rpc.cluster.support)</span><br><span class="line">    MergeableClusterInvoker(com.alibaba.dubbo.rpc.cluster.support)</span><br><span class="line">    AbstractInvoker(com.alibaba.dubbo.rpc.protocol)</span><br></pre></td></tr></table></figure><p>这些 Invoker实现类的父类 AbstractClusterInvoker.invoke() 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">// 校验是否销毁</span></span><br><span class="line">    checkWhetherDestroyed();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 directory 获得所有服务提供者 Invoker 集合</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得 LoadBalance 对象</span></span><br><span class="line">    LoadBalance loadbalance;</span><br><span class="line">    <span class="keyword">if</span> (invokers != <span class="keyword">null</span> &amp;&amp; !invokers.isEmpty()) &#123;</span><br><span class="line">        loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">invokers</span>.<span class="title">get</span>(0).<span class="title">getUrl</span>()</span></span><br><span class="line"><span class="class">                .<span class="title">getMethodParameter</span>(<span class="title">invocation</span>.<span class="title">getMethodName</span>(), <span class="title">Constants</span>.<span class="title">LOADBALANCE_KEY</span>, <span class="title">Constants</span>.<span class="title">DEFAULT_LOADBALANCE</span>))</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">Constants</span>.<span class="title">DEFAULT_LOADBALANCE</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置调用编号,若是异步调用</span></span><br><span class="line">    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行调用</span></span><br><span class="line">    <span class="keyword">return</span> doInvoke(invocation, invokers, loadbalance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FailoverClusterInvoker"><a href="#FailoverClusterInvoker" class="headerlink" title="FailoverClusterInvoker"></a>FailoverClusterInvoker</h2><p>FailoverClusterInvoker 的 doInvoke() 方法首先是获取重试次数,然后根据重试次数进行循环调用,失败后进行重试.</p><p>在 for 循环内,首先是通过 loadBalance 选择一个 Invoker,然后再通过这个 Invoker.invoke() 方法进行远程调用.如果失败了,记录下异常,并进行重试.重试时会再次调用父类的 list() 方法列举 Invoker.</p><h2 id="FailbackClusterInvoker"><a href="#FailbackClusterInvoker" class="headerlink" title="FailbackClusterInvoker"></a>FailbackClusterInvoker</h2><p>FailbackClusterInvoker 会在调用失败后,返回一个空结果给服务消费者.</p><p>并通过定时任务对失败的调用进行重传,适合执行消息通知等操作.</p><p>doInvoke() 逻辑:<br>1.先检查 可用的 invoker 集合是否为空,若为空,则抛出异常.<br>2.调用select()通过loadbalance选择一个invoker,并发起rpc调用.<br>3.若调用失败,则添加到 failed 这个map中,并延迟初始化定时任务每隔5秒遍历一次 failed 里的 invoker,发起调用,若调用成功则从中移除.</p><h2 id="FailfastClusterInvoker"><a href="#FailfastClusterInvoker" class="headerlink" title="FailfastClusterInvoker"></a>FailfastClusterInvoker</h2><p>FailfastClusterInvoker 只会进行一次调用,失败后立即抛出异常.适用于幂等操作,比如新增记录.</p><p>doInvoke() 逻辑:<br>1.先检查 可用的 invoker 集合是否为空,若为空,则抛出异常.<br>2.调用select()通过loadbalance选择一个invoker,并发起rpc调用.<br>3.若调用失败,则先判断异常类型 若是 RpcException 或 业务异常,直接抛出.否则包装一层 RpcException 并抛出.</p><h2 id="FailsafeClusterInvoker"><a href="#FailsafeClusterInvoker" class="headerlink" title="FailsafeClusterInvoker"></a>FailsafeClusterInvoker</h2><p>FailsafeClusterInvoker 是一种失败安全的 Cluster Invoker.</p><p>所谓的失败安全是指,当调用过程中出现异常时,FailsafeClusterInvoker 仅会打印异常,而不会抛出异常.适用于写入审计日志等操作.</p><p>doInvoke() 逻辑:<br>没啥好说的,调用抛异常,捕获 Throwable 异常,打印异常日志,创建 RpcResult 对象返回.</p><h2 id="ForkingClusterInvoker"><a href="#ForkingClusterInvoker" class="headerlink" title="ForkingClusterInvoker"></a>ForkingClusterInvoker</h2><p>ForkingClusterInvoker 会在运行时通过线程池创建多个线程,并发调用多个服务提供者.</p><p>只要有一个服务提供者成功返回了结果,doInvoke 方法就会立即结束运行.</p><p>ForkingClusterInvoker 的应用场景是在一些对实时性要求比较高读操作(注意是读操作,并行写操作可能不安全)下使用,但这将会耗费更多的资源.</p><p>doInvoke() 逻辑:<br>1.先检查 可用的 invoker 集合是否为空,若为空,则抛出异常.<br>2.获取并发数 forks,调用 forks 次 select()方法获得 invokers 列表<br>3.遍历 invokers, 并发调用每个 invoker.invoke(),返回结果添加到 LinkedBlockingQueue 中<br>4.main线程阻塞在 ref.poll(timeout, TimeUnit.MILLISECONDS) 上等待第一个返回结果</p><h2 id="BroadcastClusterInvoker"><a href="#BroadcastClusterInvoker" class="headerlink" title="BroadcastClusterInvoker"></a>BroadcastClusterInvoker</h2><p>BroadcastClusterInvoker 会逐个调用每个服务提供者,如果其中一台报错,在循环调用结束后,BroadcastClusterInvoker 会抛出异常.</p><p>该类通常用于通知所有提供者更新缓存或日志等本地资源信息.<br>doInvoke() 逻辑:<br>没啥好说的,循环调用 invokers,调用失败记录 exception.最后有异常就抛出.</p><p><a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/cluster.html" target="_blank" rel="noopener">官网cluster部分</a></p><h1 id="directory"><a href="#directory" class="headerlink" title="directory"></a>directory</h1><p>主要看 RegistryDirectory 的实现.</p><h2 id="RegistryDirectory"><a href="#RegistryDirectory" class="headerlink" title="RegistryDirectory"></a>RegistryDirectory</h2><p>RegistryDirectory 实现了 NotifyListener 接口,当注册中心节点信息发生变化后,RegistryDirectory 可以通过此接口方法得到变更信息.</p><p>收到变更通知后,RegistryDirectory 可根据配置变更信息刷新 Invoker 列表.</p><p>RegistryDirectory 中有几个比较重要的逻辑:<br>1.Invoker.doList() 逻辑<br>2.接收服务配置变更的逻辑<br>3.Invoker 列表的刷新逻辑</p><p>doList()逻辑:<br>没啥好说的,就是从 methodInvokerMap(即 methodInvokerMap) 缓存中获取 methodName 对应的 invokers</p><p>接收服务变更通知<br>RegistryDirectory 是一个动态服务目录,会随注册中心配置的变化进行动态调整.因此 RegistryDirectory 实现了 NotifyListener 接口,通过这个接口获取注册中心变更通知.</p><p>1.ZookeeperRegistry.doSubscribe() 订阅时会创建一个 ChildListener,当发生 childChanged 事件时,会回调它的 childChanged() 方法<br>2.调用ZookeeperRegistry.this.notify(),由于 RegistryDirectory 实现了 NotifyListener 接口,会调用 RegistryDirectory.notify()<br>3.RegistryDirectory.notify() 调用 refreshInvoker(invokerUrls);<br>将 url 转成 Invoker,得到 <code>&lt;url, Invoker&gt;</code> 的映射关系.然后进一步进行转换,得到 <code>&lt;methodName, InvokerList&gt;</code> 映射关系.之后进行多组 Invoker 合并操作,并将合并结果赋值给 methodInvokerMap.methodInvokerMap 变量在 doList 方法中会被用到,doList 会对该变量进行读操作,在这里是写操作.当新的 Invoker 列表生成后,还要一个重要的工作要做,就是销毁无用的 Invoker,避免服务消费者调用已下线的服务的服务.</p><p><a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/directory.html" target="_blank" rel="noopener">官网directory部分</a></p><h1 id="router"><a href="#router" class="headerlink" title="router"></a>router</h1><p>服务路由包含一条路由规则,路由规则决定了服务消费者的调用目标,即<code>规定了服务消费者可调用哪些服务提供者</code>.<br>比如条件路由 ConditionRouter</p><p>rule格式 [服务消费者匹配条件] =&gt; [服务提供者匹配条件],比如 rule = “host = 2.2.2.2,1.1.1.1,3.3.3.3 =&gt; host = 1.2.3.4”</p><p>ConditionRouter 构造方法里 先是对路由规则做预处理.处理结果存入 MatchPair.matches 和 MatchPair.mismatches,分别对应 匹配 和 不匹配的条件.最后 whenCondition 保存 消费者匹配条件,thenCondition 保存 提供者地址列表的过滤条件.</p><p>ConditionRouter.router(): 服务路由的逻辑.<br>1.调用 matchWhen 对服务消费者进行匹配,如果匹配失败,直接返回 Invoker 列表<br>2.如果匹配成功,再对服务提供者进行匹配</p><p>ConditionRouterTest</p><p><a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/router.html" target="_blank" rel="noopener">官网router部分</a></p><h1 id="loadBalance"><a href="#loadBalance" class="headerlink" title="loadBalance"></a>loadBalance</h1><p><a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/loadbalance.html" target="_blank" rel="noopener">官网loadBalance部分</a><br>loadBalance 类的继承结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AbstractLoadBalance (com.alibaba.dubbo.rpc.cluster.loadbalance)</span><br><span class="line">    RoundRobinLoadBalance (com.alibaba.dubbo.rpc.cluster.loadbalance)</span><br><span class="line">    LeastActiveLoadBalance (com.alibaba.dubbo.rpc.cluster.loadbalance)</span><br><span class="line">    RandomLoadBalance (com.alibaba.dubbo.rpc.cluster.loadbalance)</span><br><span class="line">    ConsistentHashLoadBalance (com.alibaba.dubbo.rpc.cluster.loadbalance)</span><br></pre></td></tr></table></figure></p><h2 id="RandomLoadBalance"><a href="#RandomLoadBalance" class="headerlink" title="RandomLoadBalance"></a>RandomLoadBalance</h2><p>按权重设置随机概率.如果所有invoker权重都相等,则随机取一个.不相等,则按照权重的比例随机取.</p><h2 id="LeastActiveLoadBalance"><a href="#LeastActiveLoadBalance" class="headerlink" title="LeastActiveLoadBalance"></a>LeastActiveLoadBalance</h2><p>最小活跃数负载均衡。活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多的请求。此时应优先将请求分配给该服务提供者。</p><p>初始情况下，所有服务提供者活跃数均为0。每收到一个请求，活跃数加1，完成请求后则将活跃数减1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求、这就是最小活跃数负载均衡算法的基本思想。</p><h2 id="ConsistentHashLoadBalance"><a href="#ConsistentHashLoadBalance" class="headerlink" title="ConsistentHashLoadBalance"></a>ConsistentHashLoadBalance</h2><p>一致性 Hash，相同参数的请求总是发到同一提供者。</p><p>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p><h2 id="RoundRobinLoadBalance"><a href="#RoundRobinLoadBalance" class="headerlink" title="RoundRobinLoadBalance"></a>RoundRobinLoadBalance</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;cluster&quot;&gt;&lt;a href=&quot;#cluster&quot; class=&quot;headerlink&quot; title=&quot;cluster&quot;&gt;&lt;/a&gt;cluster&lt;/h1&gt;&lt;p&gt;Cluster 将 Directory 中的多个 Invoker 伪装成一个 Invoker,对上层
      
    
    </summary>
    
      <category term="Dubbo" scheme="http://yoursite.com/categories/Dubbo/"/>
    
    
      <category term="Dubbo" scheme="http://yoursite.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>synchronized 和 lock 性能比较</title>
    <link href="http://yoursite.com/2019/12/03/01no/concurrent/concurrent10-sync-vs-lock/"/>
    <id>http://yoursite.com/2019/12/03/01no/concurrent/concurrent10-sync-vs-lock/</id>
    <published>2019-12-02T16:00:00.000Z</published>
    <updated>2020-03-14T03:38:51.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synchronized-与-Lock-性能比较"><a href="#synchronized-与-Lock-性能比较" class="headerlink" title="synchronized 与 Lock 性能比较"></a>synchronized 与 Lock 性能比较</h1><h2 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">D:\soft\Java\jdk1.8.0_172\bin\java.exe &quot;-javaagent:D:\soft\JetBrains\IntelliJ IDEA 2018.1.6\lib\idea_rt.jar&#x3D;57167:D:\soft\JetBrains\IntelliJ IDEA 2018.1.6\bin&quot; -Dfile.encoding&#x3D;UTF-8 -classpath &quot;D:\soft\Java\jdk1.8.0_172\jre\lib\charsets.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\deploy.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\ext\access-bridge-64.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\ext\cldrdata.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\ext\dnsns.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\ext\jaccess.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\ext\jfxrt.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\ext\localedata.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\ext\nashorn.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\ext\sunec.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\ext\sunjce_provider.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\ext\sunmscapi.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\ext\sunpkcs11.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\ext\zipfs.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\javaws.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\jce.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\jfr.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\jfxswt.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\jsse.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\management-agent.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\plugin.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\resources.jar;D:\soft\Java\jdk1.8.0_172\jre\lib\rt.jar;D:\myworkspace\03mygithub\MyThread\bin;D:\soft\JetBrains\IntelliJ IDEA 2018.1.6\lib\junit-4.12.jar;D:\soft\JetBrains\IntelliJ IDEA 2018.1.6\lib\hamcrest-core-1.3.jar&quot; com.zc.concurrent.issue.ReentrantLockVsSynchronizedTest</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数1,每个线程循环 100000 次</span><br><span class="line">3789172(elapse), testLongAdder: result&#x3D;100000, threadCount&#x3D;1, loopCount&#x3D;100000</span><br><span class="line">6642633(elapse), testReentrantLockUnfair: result&#x3D;100000, threadCount&#x3D;1, loopCount&#x3D;100000</span><br><span class="line">6841152(elapse), testReentrantLockFair: result&#x3D;100000, threadCount&#x3D;1, loopCount&#x3D;100000</span><br><span class="line">8382098(elapse), testSynchronized: result&#x3D;100000, threadCount&#x3D;1, loopCount&#x3D;100000</span><br><span class="line">44980066(elapse), testAtomicInteger: result&#x3D;100000, threadCount&#x3D;1, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数2,每个线程循环 100000 次</span><br><span class="line">2647611(elapse), testLongAdder: result&#x3D;300000, threadCount&#x3D;2, loopCount&#x3D;100000</span><br><span class="line">3772457(elapse), testAtomicInteger: result&#x3D;300000, threadCount&#x3D;2, loopCount&#x3D;100000</span><br><span class="line">5013131(elapse), testSynchronized: result&#x3D;300000, threadCount&#x3D;2, loopCount&#x3D;100000</span><br><span class="line">5831547(elapse), testReentrantLockFair: result&#x3D;300000, threadCount&#x3D;2, loopCount&#x3D;100000</span><br><span class="line">9820412(elapse), testReentrantLockUnfair: result&#x3D;300000, threadCount&#x3D;2, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数4,每个线程循环 100000 次</span><br><span class="line">2838213(elapse), testSynchronized: result&#x3D;700000, threadCount&#x3D;4, loopCount&#x3D;100000</span><br><span class="line">3695923(elapse), testAtomicInteger: result&#x3D;700000, threadCount&#x3D;4, loopCount&#x3D;100000</span><br><span class="line">12967987(elapse), testLongAdder: result&#x3D;700000, threadCount&#x3D;4, loopCount&#x3D;100000</span><br><span class="line">13843291(elapse), testReentrantLockUnfair: result&#x3D;700000, threadCount&#x3D;4, loopCount&#x3D;100000</span><br><span class="line">1132170308(elapse), testReentrantLockFair: result&#x3D;700000, threadCount&#x3D;4, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数6,每个线程循环 100000 次</span><br><span class="line">2340008(elapse), testLongAdder: result&#x3D;1300000, threadCount&#x3D;6, loopCount&#x3D;100000</span><br><span class="line">5598133(elapse), testSynchronized: result&#x3D;1300000, threadCount&#x3D;6, loopCount&#x3D;100000</span><br><span class="line">11595358(elapse), testAtomicInteger: result&#x3D;1300000, threadCount&#x3D;6, loopCount&#x3D;100000</span><br><span class="line">17305800(elapse), testReentrantLockUnfair: result&#x3D;1300000, threadCount&#x3D;6, loopCount&#x3D;100000</span><br><span class="line">1706668497(elapse), testReentrantLockFair: result&#x3D;1300000, threadCount&#x3D;6, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数8,每个线程循环 100000 次</span><br><span class="line">2604212(elapse), testLongAdder: result&#x3D;2100000, threadCount&#x3D;8, loopCount&#x3D;100000</span><br><span class="line">7267222(elapse), testSynchronized: result&#x3D;2100000, threadCount&#x3D;8, loopCount&#x3D;100000</span><br><span class="line">15585101(elapse), testAtomicInteger: result&#x3D;2100000, threadCount&#x3D;8, loopCount&#x3D;100000</span><br><span class="line">20813467(elapse), testReentrantLockUnfair: result&#x3D;2100000, threadCount&#x3D;8, loopCount&#x3D;100000</span><br><span class="line">2392860159(elapse), testReentrantLockFair: result&#x3D;2100000, threadCount&#x3D;8, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数10,每个线程循环 100000 次</span><br><span class="line">6970763(elapse), testLongAdder: result&#x3D;3100000, threadCount&#x3D;10, loopCount&#x3D;100000</span><br><span class="line">9930961(elapse), testSynchronized: result&#x3D;3100000, threadCount&#x3D;10, loopCount&#x3D;100000</span><br><span class="line">20397367(elapse), testAtomicInteger: result&#x3D;3100000, threadCount&#x3D;10, loopCount&#x3D;100000</span><br><span class="line">25850936(elapse), testReentrantLockUnfair: result&#x3D;3100000, threadCount&#x3D;10, loopCount&#x3D;100000</span><br><span class="line">2794116491(elapse), testReentrantLockFair: result&#x3D;3100000, threadCount&#x3D;10, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数50,每个线程循环 100000 次</span><br><span class="line">14844099(elapse), testLongAdder: result&#x3D;8100000, threadCount&#x3D;50, loopCount&#x3D;100000</span><br><span class="line">47918859(elapse), testSynchronized: result&#x3D;8100000, threadCount&#x3D;50, loopCount&#x3D;100000</span><br><span class="line">98661562(elapse), testAtomicInteger: result&#x3D;8100000, threadCount&#x3D;50, loopCount&#x3D;100000</span><br><span class="line">126939598(elapse), testReentrantLockUnfair: result&#x3D;8100000, threadCount&#x3D;50, loopCount&#x3D;100000</span><br><span class="line">14410074177(elapse), testReentrantLockFair: result&#x3D;8100000, threadCount&#x3D;50, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数100,每个线程循环 100000 次</span><br><span class="line">29294384(elapse), testLongAdder: result&#x3D;18100000, threadCount&#x3D;100, loopCount&#x3D;100000</span><br><span class="line">90143110(elapse), testSynchronized: result&#x3D;18100000, threadCount&#x3D;100, loopCount&#x3D;100000</span><br><span class="line">193961488(elapse), testAtomicInteger: result&#x3D;18100000, threadCount&#x3D;100, loopCount&#x3D;100000</span><br><span class="line">244101889(elapse), testReentrantLockUnfair: result&#x3D;18100000, threadCount&#x3D;100, loopCount&#x3D;100000</span><br><span class="line">31166365222(elapse), testReentrantLockFair: result&#x3D;18100000, threadCount&#x3D;100, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数200,每个线程循环 100000 次</span><br><span class="line">69702637(elapse), testLongAdder: result&#x3D;38100000, threadCount&#x3D;200, loopCount&#x3D;100000</span><br><span class="line">170973104(elapse), testSynchronized: result&#x3D;38100000, threadCount&#x3D;200, loopCount&#x3D;100000</span><br><span class="line">341206964(elapse), testAtomicInteger: result&#x3D;38100000, threadCount&#x3D;200, loopCount&#x3D;100000</span><br><span class="line">489087584(elapse), testReentrantLockUnfair: result&#x3D;38100000, threadCount&#x3D;200, loopCount&#x3D;100000</span><br><span class="line">63709112896(elapse), testReentrantLockFair: result&#x3D;38100000, threadCount&#x3D;200, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 100000 次</span><br><span class="line">133355267(elapse), testLongAdder: result&#x3D;88100000, threadCount&#x3D;500, loopCount&#x3D;100000</span><br><span class="line">465237384(elapse), testSynchronized: result&#x3D;88100000, threadCount&#x3D;500, loopCount&#x3D;100000</span><br><span class="line">982221507(elapse), testAtomicInteger: result&#x3D;88100000, threadCount&#x3D;500, loopCount&#x3D;100000</span><br><span class="line">1246923387(elapse), testReentrantLockUnfair: result&#x3D;88100000, threadCount&#x3D;500, loopCount&#x3D;100000</span><br><span class="line">163173197284(elapse), testReentrantLockFair: result&#x3D;88100000, threadCount&#x3D;500, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 10000 次</span><br><span class="line">46909254(elapse), testSynchronized: result&#x3D;93100000, threadCount&#x3D;500, loopCount&#x3D;10000</span><br><span class="line">53434593(elapse), testLongAdder: result&#x3D;93100000, threadCount&#x3D;500, loopCount&#x3D;10000</span><br><span class="line">76151149(elapse), testAtomicInteger: result&#x3D;93100000, threadCount&#x3D;500, loopCount&#x3D;10000</span><br><span class="line">115951527(elapse), testReentrantLockUnfair: result&#x3D;93100000, threadCount&#x3D;500, loopCount&#x3D;10000</span><br><span class="line">16067416290(elapse), testReentrantLockFair: result&#x3D;93100000, threadCount&#x3D;500, loopCount&#x3D;10000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 1000 次</span><br><span class="line">21785245(elapse), testLongAdder: result&#x3D;93600000, threadCount&#x3D;500, loopCount&#x3D;1000</span><br><span class="line">22926219(elapse), testSynchronized: result&#x3D;93600000, threadCount&#x3D;500, loopCount&#x3D;1000</span><br><span class="line">23726455(elapse), testAtomicInteger: result&#x3D;93600000, threadCount&#x3D;500, loopCount&#x3D;1000</span><br><span class="line">23893305(elapse), testReentrantLockUnfair: result&#x3D;93600000, threadCount&#x3D;500, loopCount&#x3D;1000</span><br><span class="line">1583798403(elapse), testReentrantLockFair: result&#x3D;93600000, threadCount&#x3D;500, loopCount&#x3D;1000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 100 次</span><br><span class="line">21886704(elapse), testSynchronized: result&#x3D;93650000, threadCount&#x3D;500, loopCount&#x3D;100</span><br><span class="line">22070561(elapse), testReentrantLockUnfair: result&#x3D;93650000, threadCount&#x3D;500, loopCount&#x3D;100</span><br><span class="line">22847925(elapse), testLongAdder: result&#x3D;93650000, threadCount&#x3D;500, loopCount&#x3D;100</span><br><span class="line">24225539(elapse), testAtomicInteger: result&#x3D;93650000, threadCount&#x3D;500, loopCount&#x3D;100</span><br><span class="line">133848487(elapse), testReentrantLockFair: result&#x3D;93650000, threadCount&#x3D;500, loopCount&#x3D;100</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 10 次</span><br><span class="line">20742504(elapse), testSynchronized: result&#x3D;93655000, threadCount&#x3D;500, loopCount&#x3D;10</span><br><span class="line">21348326(elapse), testLongAdder: result&#x3D;93655000, threadCount&#x3D;500, loopCount&#x3D;10</span><br><span class="line">21286160(elapse), testReentrantLockUnfair: result&#x3D;93655000, threadCount&#x3D;500, loopCount&#x3D;10</span><br><span class="line">21943591(elapse), testAtomicInteger: result&#x3D;93655000, threadCount&#x3D;500, loopCount&#x3D;10</span><br><span class="line">22087863(elapse), testReentrantLockFair: result&#x3D;93655000, threadCount&#x3D;500, loopCount&#x3D;10</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 1 次</span><br><span class="line">20936918(elapse), testReentrantLockUnfair: result&#x3D;93655500, threadCount&#x3D;500, loopCount&#x3D;1</span><br><span class="line">21259769(elapse), testAtomicInteger: result&#x3D;93655500, threadCount&#x3D;500, loopCount&#x3D;1</span><br><span class="line">21328093(elapse), testLongAdder: result&#x3D;93655500, threadCount&#x3D;500, loopCount&#x3D;1</span><br><span class="line">22007810(elapse), testSynchronized: result&#x3D;93655500, threadCount&#x3D;500, loopCount&#x3D;1</span><br><span class="line">23318273(elapse), testReentrantLockFair: result&#x3D;93655500, threadCount&#x3D;500, loopCount&#x3D;1</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数1000,每个线程循环 1 次</span><br><span class="line">53460398(elapse), testLongAdder: result&#x3D;1500, threadCount&#x3D;1000, loopCount&#x3D;1</span><br><span class="line">58974079(elapse), testAtomicInteger: result&#x3D;1500, threadCount&#x3D;1000, loopCount&#x3D;1</span><br><span class="line">82545706(elapse), testSynchronized: result&#x3D;1500, threadCount&#x3D;1000, loopCount&#x3D;1</span><br><span class="line">130621152(elapse), testReentrantLockFair: result&#x3D;1500, threadCount&#x3D;1000, loopCount&#x3D;1</span><br><span class="line">200410000(elapse), testReentrantLockUnfair: result&#x3D;1500, threadCount&#x3D;1000, loopCount&#x3D;1</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数1500,每个线程循环 1 次</span><br><span class="line">84837038(elapse), testSynchronized: result&#x3D;3000, threadCount&#x3D;1500, loopCount&#x3D;1</span><br><span class="line">104347079(elapse), testAtomicInteger: result&#x3D;3000, threadCount&#x3D;1500, loopCount&#x3D;1</span><br><span class="line">109697722(elapse), testReentrantLockUnfair: result&#x3D;3000, threadCount&#x3D;1500, loopCount&#x3D;1</span><br><span class="line">138776874(elapse), testReentrantLockFair: result&#x3D;3000, threadCount&#x3D;1500, loopCount&#x3D;1</span><br><span class="line">212777150(elapse), testLongAdder: result&#x3D;3000, threadCount&#x3D;1500, loopCount&#x3D;1</span><br><span class="line">-------------------------------------</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>从上面的测试数据能看出来,在JDK1.8下<code>synchronized 比 ReentrantLock 性能要好很多</code>,从上面数据来看正常能快个3~5倍这样.</p><p>ReentrantLock 公平模式性能很差,并发竞争大的情况下,从数据看 正常比 非公平模式能慢两个数量级.</p><p>AtomicInteger 和 LongAdder 在这种场景下性能还是比 ReentrantLock 要好一些的.</p><h2 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">D:\soft\Java\JDK1.7\bin\java.exe &quot;-javaagent:D:\soft\JetBrains\IntelliJ IDEA 2018.1.6\lib\idea_rt.jar&#x3D;60620:D:\soft\JetBrains\IntelliJ IDEA 2018.1.6\bin&quot; -Dfile.encoding&#x3D;UTF-8 -classpath D:\soft\Java\JDK1.7\jre\lib\charsets.jar;D:\soft\Java\JDK1.7\jre\lib\deploy.jar;D:\soft\Java\JDK1.7\jre\lib\ext\access-bridge-64.jar;D:\soft\Java\JDK1.7\jre\lib\ext\dnsns.jar;D:\soft\Java\JDK1.7\jre\lib\ext\jaccess.jar;D:\soft\Java\JDK1.7\jre\lib\ext\localedata.jar;D:\soft\Java\JDK1.7\jre\lib\ext\sunec.jar;D:\soft\Java\JDK1.7\jre\lib\ext\sunjce_provider.jar;D:\soft\Java\JDK1.7\jre\lib\ext\sunmscapi.jar;D:\soft\Java\JDK1.7\jre\lib\ext\zipfs.jar;D:\soft\Java\JDK1.7\jre\lib\javaws.jar;D:\soft\Java\JDK1.7\jre\lib\jce.jar;D:\soft\Java\JDK1.7\jre\lib\jfr.jar;D:\soft\Java\JDK1.7\jre\lib\jfxrt.jar;D:\soft\Java\JDK1.7\jre\lib\jsse.jar;D:\soft\Java\JDK1.7\jre\lib\management-agent.jar;D:\soft\Java\JDK1.7\jre\lib\plugin.jar;D:\soft\Java\JDK1.7\jre\lib\resources.jar;D:\soft\Java\JDK1.7\jre\lib\rt.jar;D:\myworkspace\02localdemo\T03TomLoader\target\classes com.zc.test.ReentrantLockVsSynchronizedTest</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数1,每个线程循环 100000 次</span><br><span class="line">22840888(elapse), testSynchronized: result&#x3D;100000, threadCount&#x3D;1, loopCount&#x3D;100000</span><br><span class="line">26080245(elapse), testAtomicInteger: result&#x3D;100000, threadCount&#x3D;1, loopCount&#x3D;100000</span><br><span class="line">8243398(elapse), testReentrantLockUnfair: result&#x3D;100000, threadCount&#x3D;1, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数2,每个线程循环 100000 次</span><br><span class="line">5484065(elapse), testSynchronized: result&#x3D;300000, threadCount&#x3D;2, loopCount&#x3D;100000</span><br><span class="line">5490809(elapse), testAtomicInteger: result&#x3D;300000, threadCount&#x3D;2, loopCount&#x3D;100000</span><br><span class="line">11825254(elapse), testReentrantLockUnfair: result&#x3D;300000, threadCount&#x3D;2, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数4,每个线程循环 100000 次</span><br><span class="line">11477771(elapse), testSynchronized: result&#x3D;700000, threadCount&#x3D;4, loopCount&#x3D;100000</span><br><span class="line">15624982(elapse), testReentrantLockUnfair: result&#x3D;700000, threadCount&#x3D;4, loopCount&#x3D;100000</span><br><span class="line">29080910(elapse), testAtomicInteger: result&#x3D;700000, threadCount&#x3D;4, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数6,每个线程循环 100000 次</span><br><span class="line">15473673(elapse), testSynchronized: result&#x3D;1300000, threadCount&#x3D;6, loopCount&#x3D;100000</span><br><span class="line">32343434(elapse), testAtomicInteger: result&#x3D;1300000, threadCount&#x3D;6, loopCount&#x3D;100000</span><br><span class="line">35170504(elapse), testReentrantLockUnfair: result&#x3D;1300000, threadCount&#x3D;6, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数8,每个线程循环 100000 次</span><br><span class="line">18780768(elapse), testSynchronized: result&#x3D;2100000, threadCount&#x3D;8, loopCount&#x3D;100000</span><br><span class="line">19249649(elapse), testReentrantLockUnfair: result&#x3D;2100000, threadCount&#x3D;8, loopCount&#x3D;100000</span><br><span class="line">51532676(elapse), testAtomicInteger: result&#x3D;2100000, threadCount&#x3D;8, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数10,每个线程循环 100000 次</span><br><span class="line">22142404(elapse), testReentrantLockUnfair: result&#x3D;3100000, threadCount&#x3D;10, loopCount&#x3D;100000</span><br><span class="line">28116170(elapse), testSynchronized: result&#x3D;3100000, threadCount&#x3D;10, loopCount&#x3D;100000</span><br><span class="line">46799583(elapse), testAtomicInteger: result&#x3D;3100000, threadCount&#x3D;10, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数50,每个线程循环 100000 次</span><br><span class="line">154866338(elapse), testReentrantLockUnfair: result&#x3D;8100000, threadCount&#x3D;50, loopCount&#x3D;100000</span><br><span class="line">164094417(elapse), testSynchronized: result&#x3D;8100000, threadCount&#x3D;50, loopCount&#x3D;100000</span><br><span class="line">190372008(elapse), testAtomicInteger: result&#x3D;8100000, threadCount&#x3D;50, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数100,每个线程循环 100000 次</span><br><span class="line">320082668(elapse), testSynchronized: result&#x3D;18100000, threadCount&#x3D;100, loopCount&#x3D;100000</span><br><span class="line">399773154(elapse), testAtomicInteger: result&#x3D;18100000, threadCount&#x3D;100, loopCount&#x3D;100000</span><br><span class="line">669262375(elapse), testReentrantLockUnfair: result&#x3D;18100000, threadCount&#x3D;100, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数200,每个线程循环 100000 次</span><br><span class="line">557621097(elapse), testReentrantLockUnfair: result&#x3D;38100000, threadCount&#x3D;200, loopCount&#x3D;100000</span><br><span class="line">650982745(elapse), testSynchronized: result&#x3D;38100000, threadCount&#x3D;200, loopCount&#x3D;100000</span><br><span class="line">1287148955(elapse), testAtomicInteger: result&#x3D;38100000, threadCount&#x3D;200, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 100000 次</span><br><span class="line">1319411162(elapse), testReentrantLockUnfair: result&#x3D;88100000, threadCount&#x3D;500, loopCount&#x3D;100000</span><br><span class="line">1496867673(elapse), testSynchronized: result&#x3D;88100000, threadCount&#x3D;500, loopCount&#x3D;100000</span><br><span class="line">2878890484(elapse), testAtomicInteger: result&#x3D;88100000, threadCount&#x3D;500, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 10000 次</span><br><span class="line">134509730(elapse), testReentrantLockUnfair: result&#x3D;93100000, threadCount&#x3D;500, loopCount&#x3D;10000</span><br><span class="line">170702742(elapse), testSynchronized: result&#x3D;93100000, threadCount&#x3D;500, loopCount&#x3D;10000</span><br><span class="line">250160106(elapse), testAtomicInteger: result&#x3D;93100000, threadCount&#x3D;500, loopCount&#x3D;10000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 1000 次</span><br><span class="line">27824108(elapse), testReentrantLockUnfair: result&#x3D;93600000, threadCount&#x3D;500, loopCount&#x3D;1000</span><br><span class="line">40523787(elapse), testSynchronized: result&#x3D;93600000, threadCount&#x3D;500, loopCount&#x3D;1000</span><br><span class="line">40963344(elapse), testAtomicInteger: result&#x3D;93600000, threadCount&#x3D;500, loopCount&#x3D;1000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 100 次</span><br><span class="line">24163960(elapse), testSynchronized: result&#x3D;93650000, threadCount&#x3D;500, loopCount&#x3D;100</span><br><span class="line">24996452(elapse), testAtomicInteger: result&#x3D;93650000, threadCount&#x3D;500, loopCount&#x3D;100</span><br><span class="line">35085760(elapse), testReentrantLockUnfair: result&#x3D;93650000, threadCount&#x3D;500, loopCount&#x3D;100</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 10 次</span><br><span class="line">40494463(elapse), testReentrantLockUnfair: result&#x3D;93655000, threadCount&#x3D;500, loopCount&#x3D;10</span><br><span class="line">51199269(elapse), testSynchronized: result&#x3D;93655000, threadCount&#x3D;500, loopCount&#x3D;10</span><br><span class="line">52468973(elapse), testAtomicInteger: result&#x3D;93655000, threadCount&#x3D;500, loopCount&#x3D;10</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 1 次</span><br><span class="line">44156664(elapse), testAtomicInteger: result&#x3D;93655500, threadCount&#x3D;500, loopCount&#x3D;1</span><br><span class="line">46565583(elapse), testSynchronized: result&#x3D;93655500, threadCount&#x3D;500, loopCount&#x3D;1</span><br><span class="line">144862068(elapse), testReentrantLockUnfair: result&#x3D;93655500, threadCount&#x3D;500, loopCount&#x3D;1</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数1000,每个线程循环 1 次</span><br><span class="line">111706963(elapse), testReentrantLockUnfair: result&#x3D;93656500, threadCount&#x3D;1000, loopCount&#x3D;1</span><br><span class="line">156553607(elapse), testAtomicInteger: result&#x3D;93656500, threadCount&#x3D;1000, loopCount&#x3D;1</span><br><span class="line">182228017(elapse), testSynchronized: result&#x3D;93656500, threadCount&#x3D;1000, loopCount&#x3D;1</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数1500,每个线程循环 1 次</span><br><span class="line">176627244(elapse), testSynchronized: result&#x3D;93658000, threadCount&#x3D;1500, loopCount&#x3D;1</span><br><span class="line">202298721(elapse), testAtomicInteger: result&#x3D;93658000, threadCount&#x3D;1500, loopCount&#x3D;1</span><br><span class="line">69693840(elapse), testReentrantLockUnfair: result&#x3D;93658000, threadCount&#x3D;1500, loopCount&#x3D;1</span><br><span class="line">-------------------------------------</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>从数据上看,正常情况下还是 synchronized 稍微快一点的.有比 ReentrantLock(非公平)慢的时候,最多也就慢一倍这样.</p><h2 id="JDK1-6"><a href="#JDK1-6" class="headerlink" title="JDK1.6"></a>JDK1.6</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">D:\soft\Java\jdk1.6.0_45\bin\java.exe &quot;-javaagent:D:\soft\JetBrains\IntelliJ IDEA 2018.1.6\lib\idea_rt.jar&#x3D;61893:D:\soft\JetBrains\IntelliJ IDEA 2018.1.6\bin&quot; -Dfile.encoding&#x3D;UTF-8 -classpath D:\soft\Java\jdk1.6.0_45\jre\lib\charsets.jar;D:\soft\Java\jdk1.6.0_45\jre\lib\deploy.jar;D:\soft\Java\jdk1.6.0_45\jre\lib\ext\dnsns.jar;D:\soft\Java\jdk1.6.0_45\jre\lib\ext\localedata.jar;D:\soft\Java\jdk1.6.0_45\jre\lib\ext\sunjce_provider.jar;D:\soft\Java\jdk1.6.0_45\jre\lib\ext\sunmscapi.jar;D:\soft\Java\jdk1.6.0_45\jre\lib\javaws.jar;D:\soft\Java\jdk1.6.0_45\jre\lib\jce.jar;D:\soft\Java\jdk1.6.0_45\jre\lib\jsse.jar;D:\soft\Java\jdk1.6.0_45\jre\lib\management-agent.jar;D:\soft\Java\jdk1.6.0_45\jre\lib\plugin.jar;D:\soft\Java\jdk1.6.0_45\jre\lib\resources.jar;D:\soft\Java\jdk1.6.0_45\jre\lib\rt.jar;D:\myworkspace\02localdemo\T03TomLoader\target\classes com.zc.test.ReentrantLockVsSynchronizedTest</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数1,每个线程循环 100000 次</span><br><span class="line">4767108(elapse), testAtomicInteger: result&#x3D;100000, threadCount&#x3D;1, loopCount&#x3D;100000</span><br><span class="line">5231298(elapse), testSynchronized: result&#x3D;100000, threadCount&#x3D;1, loopCount&#x3D;100000</span><br><span class="line">11269281(elapse), testReentrantLockUnfair: result&#x3D;100000, threadCount&#x3D;1, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数2,每个线程循环 100000 次</span><br><span class="line">2265820(elapse), testAtomicInteger: result&#x3D;300000, threadCount&#x3D;2, loopCount&#x3D;100000</span><br><span class="line">5181154(elapse), testSynchronized: result&#x3D;300000, threadCount&#x3D;2, loopCount&#x3D;100000</span><br><span class="line">9388771(elapse), testReentrantLockUnfair: result&#x3D;300000, threadCount&#x3D;2, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数4,每个线程循环 100000 次</span><br><span class="line">10028901(elapse), testSynchronized: result&#x3D;700000, threadCount&#x3D;4, loopCount&#x3D;100000</span><br><span class="line">28028493(elapse), testAtomicInteger: result&#x3D;700000, threadCount&#x3D;4, loopCount&#x3D;100000</span><br><span class="line">9190838(elapse), testReentrantLockUnfair: result&#x3D;700000, threadCount&#x3D;4, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数6,每个线程循环 100000 次</span><br><span class="line">15937569(elapse), testReentrantLockUnfair: result&#x3D;1300000, threadCount&#x3D;6, loopCount&#x3D;100000</span><br><span class="line">17108746(elapse), testSynchronized: result&#x3D;1300000, threadCount&#x3D;6, loopCount&#x3D;100000</span><br><span class="line">21985524(elapse), testAtomicInteger: result&#x3D;1300000, threadCount&#x3D;6, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数8,每个线程循环 100000 次</span><br><span class="line">20291510(elapse), testReentrantLockUnfair: result&#x3D;2100000, threadCount&#x3D;8, loopCount&#x3D;100000</span><br><span class="line">20961550(elapse), testSynchronized: result&#x3D;2100000, threadCount&#x3D;8, loopCount&#x3D;100000</span><br><span class="line">36662479(elapse), testAtomicInteger: result&#x3D;2100000, threadCount&#x3D;8, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数10,每个线程循环 100000 次</span><br><span class="line">21589658(elapse), testAtomicInteger: result&#x3D;3100000, threadCount&#x3D;10, loopCount&#x3D;100000</span><br><span class="line">23756071(elapse), testReentrantLockUnfair: result&#x3D;3100000, threadCount&#x3D;10, loopCount&#x3D;100000</span><br><span class="line">27164038(elapse), testSynchronized: result&#x3D;3100000, threadCount&#x3D;10, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数50,每个线程循环 100000 次</span><br><span class="line">126872447(elapse), testReentrantLockUnfair: result&#x3D;8100000, threadCount&#x3D;50, loopCount&#x3D;100000</span><br><span class="line">149717147(elapse), testSynchronized: result&#x3D;8100000, threadCount&#x3D;50, loopCount&#x3D;100000</span><br><span class="line">296352695(elapse), testAtomicInteger: result&#x3D;8100000, threadCount&#x3D;50, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数100,每个线程循环 100000 次</span><br><span class="line">240213603(elapse), testSynchronized: result&#x3D;18100000, threadCount&#x3D;100, loopCount&#x3D;100000</span><br><span class="line">246687627(elapse), testReentrantLockUnfair: result&#x3D;18100000, threadCount&#x3D;100, loopCount&#x3D;100000</span><br><span class="line">324364767(elapse), testAtomicInteger: result&#x3D;18100000, threadCount&#x3D;100, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数200,每个线程循环 100000 次</span><br><span class="line">522835023(elapse), testReentrantLockUnfair: result&#x3D;38100000, threadCount&#x3D;200, loopCount&#x3D;100000</span><br><span class="line">749915548(elapse), testSynchronized: result&#x3D;38100000, threadCount&#x3D;200, loopCount&#x3D;100000</span><br><span class="line">1348022018(elapse), testAtomicInteger: result&#x3D;38100000, threadCount&#x3D;200, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 100000 次</span><br><span class="line">1252515069(elapse), testReentrantLockUnfair: result&#x3D;88100000, threadCount&#x3D;500, loopCount&#x3D;100000</span><br><span class="line">1796960863(elapse), testSynchronized: result&#x3D;88100000, threadCount&#x3D;500, loopCount&#x3D;100000</span><br><span class="line">3533896401(elapse), testAtomicInteger: result&#x3D;88100000, threadCount&#x3D;500, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 10000 次</span><br><span class="line">120825372(elapse), testReentrantLockUnfair: result&#x3D;93100000, threadCount&#x3D;500, loopCount&#x3D;10000</span><br><span class="line">173094359(elapse), testSynchronized: result&#x3D;93100000, threadCount&#x3D;500, loopCount&#x3D;10000</span><br><span class="line">327061935(elapse), testAtomicInteger: result&#x3D;93100000, threadCount&#x3D;500, loopCount&#x3D;10000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 1000 次</span><br><span class="line">25813109(elapse), testReentrantLockUnfair: result&#x3D;93600000, threadCount&#x3D;500, loopCount&#x3D;1000</span><br><span class="line">26570239(elapse), testSynchronized: result&#x3D;93600000, threadCount&#x3D;500, loopCount&#x3D;1000</span><br><span class="line">28246953(elapse), testAtomicInteger: result&#x3D;93600000, threadCount&#x3D;500, loopCount&#x3D;1000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 100 次</span><br><span class="line">25892576(elapse), testReentrantLockUnfair: result&#x3D;93650000, threadCount&#x3D;500, loopCount&#x3D;100</span><br><span class="line">26211908(elapse), testAtomicInteger: result&#x3D;93650000, threadCount&#x3D;500, loopCount&#x3D;100</span><br><span class="line">32821991(elapse), testSynchronized: result&#x3D;93650000, threadCount&#x3D;500, loopCount&#x3D;100</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 10 次</span><br><span class="line">24638120(elapse), testAtomicInteger: result&#x3D;93655000, threadCount&#x3D;500, loopCount&#x3D;10</span><br><span class="line">28614668(elapse), testSynchronized: result&#x3D;93655000, threadCount&#x3D;500, loopCount&#x3D;10</span><br><span class="line">28632262(elapse), testReentrantLockUnfair: result&#x3D;93655000, threadCount&#x3D;500, loopCount&#x3D;10</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 1 次</span><br><span class="line">28014418(elapse), testAtomicInteger: result&#x3D;93655500, threadCount&#x3D;500, loopCount&#x3D;1</span><br><span class="line">30410727(elapse), testSynchronized: result&#x3D;93655500, threadCount&#x3D;500, loopCount&#x3D;1</span><br><span class="line">37675310(elapse), testReentrantLockUnfair: result&#x3D;93655500, threadCount&#x3D;500, loopCount&#x3D;1</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数1000,每个线程循环 1 次</span><br><span class="line">49730166(elapse), testAtomicInteger: result&#x3D;93656500, threadCount&#x3D;1000, loopCount&#x3D;1</span><br><span class="line">54536567(elapse), testSynchronized: result&#x3D;93656500, threadCount&#x3D;1000, loopCount&#x3D;1</span><br><span class="line">55911835(elapse), testReentrantLockUnfair: result&#x3D;93656500, threadCount&#x3D;1000, loopCount&#x3D;1</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数1500,每个线程循环 1 次</span><br><span class="line">77436982(elapse), testReentrantLockUnfair: result&#x3D;93658000, threadCount&#x3D;1500, loopCount&#x3D;1</span><br><span class="line">80245284(elapse), testSynchronized: result&#x3D;93658000, threadCount&#x3D;1500, loopCount&#x3D;1</span><br><span class="line">82252179(elapse), testAtomicInteger: result&#x3D;93658000, threadCount&#x3D;1500, loopCount&#x3D;1</span><br><span class="line">-------------------------------------</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>从上面数据看,线程数大于等于6后 ReentrantLockUnfair 快于 synchronized,线程数小的时候 synchronized 快一些.</p><h2 id="JDK11"><a href="#JDK11" class="headerlink" title="JDK11"></a>JDK11</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">D:\soft\Java\jdk-11.0.4\bin\java.exe -Didea.launcher.port&#x3D;62514 &quot;-Didea.launcher.bin.path&#x3D;D:\soft\JetBrains\IntelliJ IDEA 2018.1.6\bin&quot; -Dfile.encoding&#x3D;UTF-8 -classpath &quot;D:\myworkspace\02localdemo\T03TomLoader\target\classes;D:\soft\JetBrains\IntelliJ IDEA 2018.1.6\lib\idea_rt.jar&quot; com.intellij.rt.execution.application.AppMainV2 com.zc.test.ReentrantLockVsSynchronizedTest</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数1,每个线程循环 100000 次</span><br><span class="line">4207617(elapse), testAtomicInteger: result&#x3D;100000, threadCount&#x3D;1, loopCount&#x3D;100000</span><br><span class="line">7003311(elapse), testSynchronized: result&#x3D;100000, threadCount&#x3D;1, loopCount&#x3D;100000</span><br><span class="line">12754512(elapse), testReentrantLockUnfair: result&#x3D;100000, threadCount&#x3D;1, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数2,每个线程循环 100000 次</span><br><span class="line">4266557(elapse), testAtomicInteger: result&#x3D;300000, threadCount&#x3D;2, loopCount&#x3D;100000</span><br><span class="line">6544986(elapse), testSynchronized: result&#x3D;300000, threadCount&#x3D;2, loopCount&#x3D;100000</span><br><span class="line">10791310(elapse), testReentrantLockUnfair: result&#x3D;300000, threadCount&#x3D;2, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数4,每个线程循环 100000 次</span><br><span class="line">7923773(elapse), testAtomicInteger: result&#x3D;700000, threadCount&#x3D;4, loopCount&#x3D;100000</span><br><span class="line">9049499(elapse), testReentrantLockUnfair: result&#x3D;700000, threadCount&#x3D;4, loopCount&#x3D;100000</span><br><span class="line">10100450(elapse), testSynchronized: result&#x3D;700000, threadCount&#x3D;4, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数6,每个线程循环 100000 次</span><br><span class="line">13618380(elapse), testAtomicInteger: result&#x3D;1300000, threadCount&#x3D;6, loopCount&#x3D;100000</span><br><span class="line">14245901(elapse), testReentrantLockUnfair: result&#x3D;1300000, threadCount&#x3D;6, loopCount&#x3D;100000</span><br><span class="line">15905607(elapse), testSynchronized: result&#x3D;1300000, threadCount&#x3D;6, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数8,每个线程循环 100000 次</span><br><span class="line">14097525(elapse), testAtomicInteger: result&#x3D;2100000, threadCount&#x3D;8, loopCount&#x3D;100000</span><br><span class="line">14484007(elapse), testSynchronized: result&#x3D;2100000, threadCount&#x3D;8, loopCount&#x3D;100000</span><br><span class="line">20932226(elapse), testReentrantLockUnfair: result&#x3D;2100000, threadCount&#x3D;8, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数10,每个线程循环 100000 次</span><br><span class="line">9905157(elapse), testAtomicInteger: result&#x3D;3100000, threadCount&#x3D;10, loopCount&#x3D;100000</span><br><span class="line">28208539(elapse), testSynchronized: result&#x3D;3100000, threadCount&#x3D;10, loopCount&#x3D;100000</span><br><span class="line">40982698(elapse), testReentrantLockUnfair: result&#x3D;3100000, threadCount&#x3D;10, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数50,每个线程循环 100000 次</span><br><span class="line">67569652(elapse), testAtomicInteger: result&#x3D;8100000, threadCount&#x3D;50, loopCount&#x3D;100000</span><br><span class="line">119220208(elapse), testReentrantLockUnfair: result&#x3D;8100000, threadCount&#x3D;50, loopCount&#x3D;100000</span><br><span class="line">127837187(elapse), testSynchronized: result&#x3D;8100000, threadCount&#x3D;50, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数100,每个线程循环 100000 次</span><br><span class="line">155161331(elapse), testAtomicInteger: result&#x3D;18100000, threadCount&#x3D;100, loopCount&#x3D;100000</span><br><span class="line">214199043(elapse), testSynchronized: result&#x3D;18100000, threadCount&#x3D;100, loopCount&#x3D;100000</span><br><span class="line">271890809(elapse), testReentrantLockUnfair: result&#x3D;18100000, threadCount&#x3D;100, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数200,每个线程循环 100000 次</span><br><span class="line">346384305(elapse), testAtomicInteger: result&#x3D;38100000, threadCount&#x3D;200, loopCount&#x3D;100000</span><br><span class="line">465400423(elapse), testReentrantLockUnfair: result&#x3D;38100000, threadCount&#x3D;200, loopCount&#x3D;100000</span><br><span class="line">658154372(elapse), testSynchronized: result&#x3D;38100000, threadCount&#x3D;200, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 100000 次</span><br><span class="line">930565965(elapse), testAtomicInteger: result&#x3D;88100000, threadCount&#x3D;500, loopCount&#x3D;100000</span><br><span class="line">1305456443(elapse), testReentrantLockUnfair: result&#x3D;88100000, threadCount&#x3D;500, loopCount&#x3D;100000</span><br><span class="line">1745141403(elapse), testSynchronized: result&#x3D;88100000, threadCount&#x3D;500, loopCount&#x3D;100000</span><br><span class="line">-------------------------------------</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 10000 次</span><br><span class="line">88273743(elapse), testAtomicInteger: result&#x3D;93100000, threadCount&#x3D;500, loopCount&#x3D;10000</span><br><span class="line">132994002(elapse), testReentrantLockUnfair: result&#x3D;93100000, threadCount&#x3D;500, loopCount&#x3D;10000</span><br><span class="line">165907776(elapse), testSynchronized: result&#x3D;93100000, threadCount&#x3D;500, loopCount&#x3D;10000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 1000 次</span><br><span class="line">32739299(elapse), testAtomicInteger: result&#x3D;93600000, threadCount&#x3D;500, loopCount&#x3D;1000</span><br><span class="line">34829766(elapse), testSynchronized: result&#x3D;93600000, threadCount&#x3D;500, loopCount&#x3D;1000</span><br><span class="line">37466527(elapse), testReentrantLockUnfair: result&#x3D;93600000, threadCount&#x3D;500, loopCount&#x3D;1000</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 100 次</span><br><span class="line">34564096(elapse), testReentrantLockUnfair: result&#x3D;93650000, threadCount&#x3D;500, loopCount&#x3D;100</span><br><span class="line">35123587(elapse), testAtomicInteger: result&#x3D;93650000, threadCount&#x3D;500, loopCount&#x3D;100</span><br><span class="line">40711163(elapse), testSynchronized: result&#x3D;93650000, threadCount&#x3D;500, loopCount&#x3D;100</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 10 次</span><br><span class="line">33697882(elapse), testAtomicInteger: result&#x3D;93655000, threadCount&#x3D;500, loopCount&#x3D;10</span><br><span class="line">34600750(elapse), testSynchronized: result&#x3D;93655000, threadCount&#x3D;500, loopCount&#x3D;10</span><br><span class="line">36510584(elapse), testReentrantLockUnfair: result&#x3D;93655000, threadCount&#x3D;500, loopCount&#x3D;10</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数500,每个线程循环 1 次</span><br><span class="line">35484557(elapse), testAtomicInteger: result&#x3D;93655500, threadCount&#x3D;500, loopCount&#x3D;1</span><br><span class="line">35623551(elapse), testReentrantLockUnfair: result&#x3D;93655500, threadCount&#x3D;500, loopCount&#x3D;1</span><br><span class="line">36133778(elapse), testSynchronized: result&#x3D;93655500, threadCount&#x3D;500, loopCount&#x3D;1</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数1000,每个线程循环 1 次</span><br><span class="line">66762085(elapse), testAtomicInteger: result&#x3D;93656500, threadCount&#x3D;1000, loopCount&#x3D;1</span><br><span class="line">67941473(elapse), testReentrantLockUnfair: result&#x3D;93656500, threadCount&#x3D;1000, loopCount&#x3D;1</span><br><span class="line">74041623(elapse), testSynchronized: result&#x3D;93656500, threadCount&#x3D;1000, loopCount&#x3D;1</span><br><span class="line">-------------------------------------</span><br><span class="line">&#x2F;&#x2F; 线程数1500,每个线程循环 1 次</span><br><span class="line">98764781(elapse), testReentrantLockUnfair: result&#x3D;93658000, threadCount&#x3D;1500, loopCount&#x3D;1</span><br><span class="line">100622126(elapse), testSynchronized: result&#x3D;93658000, threadCount&#x3D;1500, loopCount&#x3D;1</span><br><span class="line">102833697(elapse), testAtomicInteger: result&#x3D;93658000, threadCount&#x3D;1500, loopCount&#x3D;1</span><br><span class="line">-------------------------------------</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>线程数少的时候还是 synchronized 快,线程数多的时候二者基本持平.</p><h2 id="测试使用的代码"><a href="#测试使用的代码" class="headerlink" title="测试使用的代码"></a>测试使用的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.concurrent.issue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="comment">// import java.util.concurrent.atomic.LongAdder;</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.LongAdder;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockVsSynchronizedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger a = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JDK8 才有</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LongAdder b = <span class="keyword">new</span> LongAdder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock fairLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock unfairLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        testAll(<span class="number">1</span>, <span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        testAll(<span class="number">2</span>, <span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        testAll(<span class="number">4</span>, <span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        testAll(<span class="number">6</span>, <span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        testAll(<span class="number">8</span>, <span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        testAll(<span class="number">10</span>, <span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        testAll(<span class="number">50</span>, <span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        testAll(<span class="number">100</span>, <span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        testAll(<span class="number">200</span>, <span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        testAll(<span class="number">500</span>, <span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        testAll(<span class="number">500</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        testAll(<span class="number">500</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        testAll(<span class="number">500</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        testAll(<span class="number">500</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        testAll(<span class="number">500</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        testAll(<span class="number">1000</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        testAll(<span class="number">1500</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAll</span><span class="params">(<span class="keyword">int</span> threadCount, <span class="keyword">int</span> loopCount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        testAtomicInteger(threadCount, loopCount);</span><br><span class="line"></span><br><span class="line">        testLongAdder(threadCount, loopCount);</span><br><span class="line"></span><br><span class="line">        testSynchronized(threadCount, loopCount);</span><br><span class="line"></span><br><span class="line">        testReentrantLockUnfair(threadCount, loopCount);</span><br><span class="line"></span><br><span class="line">        testReentrantLockFair(threadCount, loopCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAtomicInteger</span><span class="params">(<span class="keyword">int</span> threadCount, <span class="keyword">int</span> loopCount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopCount; j++) &#123;</span><br><span class="line">                    a.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println((System.nanoTime() - start) + <span class="string">"(elapse), "</span> + <span class="string">"testAtomicInteger: result="</span> + a.get() + <span class="string">", threadCount="</span> + threadCount + <span class="string">", loopCount="</span> + loopCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testLongAdder</span><span class="params">(<span class="keyword">int</span> threadCount, <span class="keyword">int</span> loopCount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopCount; j++) &#123;</span><br><span class="line">                    b.increment();</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println((System.nanoTime() - start) + <span class="string">"(elapse), "</span> + <span class="string">"testLongAdder: result="</span> + b.sum() + <span class="string">", threadCount="</span> + threadCount + <span class="string">", loopCount="</span> + loopCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReentrantLockFair</span><span class="params">(<span class="keyword">int</span> threadCount, <span class="keyword">int</span> loopCount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopCount; j++) &#123;</span><br><span class="line">                    fairLock.lock();</span><br><span class="line">                    c++;</span><br><span class="line">                    fairLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println((System.nanoTime() - start) + <span class="string">"(elapse), "</span> + <span class="string">"testReentrantLockFair: result="</span> + c + <span class="string">", threadCount="</span> + threadCount + <span class="string">", loopCount="</span> + loopCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReentrantLockUnfair</span><span class="params">(<span class="keyword">int</span> threadCount, <span class="keyword">int</span> loopCount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopCount; j++) &#123;</span><br><span class="line">                    unfairLock.lock();</span><br><span class="line">                    d++;</span><br><span class="line">                    unfairLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println((System.nanoTime() - start) + <span class="string">"(elapse), "</span> + <span class="string">"testReentrantLockUnfair: result="</span> + d + <span class="string">", threadCount="</span> + threadCount + <span class="string">", loopCount="</span> + loopCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSynchronized</span><span class="params">(<span class="keyword">int</span> threadCount, <span class="keyword">int</span> loopCount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopCount; j++) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (ReentrantLockVsSynchronizedTest<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                        e++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println((System.nanoTime() - start) + <span class="string">"(elapse), "</span> + <span class="string">"testSynchronized: result="</span> + e + <span class="string">", threadCount="</span> + threadCount + <span class="string">", loopCount="</span> + loopCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;synchronized-与-Lock-性能比较&quot;&gt;&lt;a href=&quot;#synchronized-与-Lock-性能比较&quot; class=&quot;headerlink&quot; title=&quot;synchronized 与 Lock 性能比较&quot;&gt;&lt;/a&gt;synchronized 与
      
    
    </summary>
    
      <category term="Concurrent" scheme="http://yoursite.com/categories/Concurrent/"/>
    
    
      <category term="Concurrent" scheme="http://yoursite.com/tags/Concurrent/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo 服务暴露</title>
    <link href="http://yoursite.com/2019/11/29/01no/dubbo/dubbo03-export/"/>
    <id>http://yoursite.com/2019/11/29/01no/dubbo/dubbo03-export/</id>
    <published>2019-11-28T16:00:00.000Z</published>
    <updated>2020-05-24T14:09:30.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dubbo-与-Spring-的结合"><a href="#Dubbo-与-Spring-的结合" class="headerlink" title="Dubbo 与 Spring 的结合"></a>Dubbo 与 Spring 的结合</h1><p>代码在 dubbo-config 下的 dubbo-config-spring 模块中</p><p><img src="https://gitee.com/flyingzc/MyImg/raw/master/img/dubbo/Dubbo-Config类图.png" alt="Dubbo Config整体类图"></p><h2 id="META-INF-dubbo-xsd"><a href="#META-INF-dubbo-xsd" class="headerlink" title="META-INF/dubbo.xsd"></a>META-INF/dubbo.xsd</h2><p>dubbo.xsd 定义了 dubbo 自定义标签</p><h2 id="META-INF-spring-schemas"><a href="#META-INF-spring-schemas" class="headerlink" title="META-INF/spring.schemas"></a>META-INF/spring.schemas</h2><p>spring.schemas 指定了 dubbo.xsd 文件的位置.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&#x3D;META-INF&#x2F;dubbo.xsd</span><br></pre></td></tr></table></figure></p><h2 id="META-INF-spring-handlers"><a href="#META-INF-spring-handlers" class="headerlink" title="META-INF/spring.handlers"></a>META-INF/spring.handlers</h2><p>关联 DubboNamespaceHandler 命名空间处理器和 dubbo.xsd 中的 targetNamespace,即 <code>http://code.alibabatech.com/schema/dubbo</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x3D;com.alibaba.dubbo.config.spring.schema.DubboNamespaceHand</span><br></pre></td></tr></table></figure></p><h2 id="DubboNamespaceHandler-init"><a href="#DubboNamespaceHandler-init" class="headerlink" title="DubboNamespaceHandler.init()"></a>DubboNamespaceHandler.init()</h2><p>DubboNamespaceHandler.init(): 注册各个自定义元素的解析器,所有元素都是交给 DubboBeanDefinitionParser 处理的,传入不同的 Class 对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="comment">// 注册BeanDefinitionParser用来解析dubbo定义的那些xml元素节点</span></span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"application"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ApplicationConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;<span class="comment">// &lt;dubbo:application name="dubbo-admin" /&gt;</span></span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"module"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ModuleConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;<span class="comment">// &lt;dubbo:registry address="$&#123;dubbo.registry.address&#125;" check="false" file="false" /&gt;</span></span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"registry"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(RegistryConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;<span class="comment">// &lt;dubbo:reference id="registryService" interface="com.alibaba.dubbo.registry.RegistryService" check="false" /&gt;</span></span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"monitor"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(MonitorConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"provider"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProviderConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"consumer"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ConsumerConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"protocol"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProtocolConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">    <span class="comment">//  &lt;dubbo:service  interface="com.alibaba.dubbo.demo.DemoService" group="g1" ref="demoService" filter="demo" deprecated="false" callbacks="1000" timeout="200000" accesslog="true"&gt; 解析成 ServiceBean</span></span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"service"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ServiceBean<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"reference"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ReferenceBean<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>))</span>;</span><br><span class="line"></span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"annotation"</span>, <span class="keyword">new</span> AnnotationBeanDefinitionParser()); <span class="comment">// 废弃</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="DubboBeanDefinitionParser"><a href="#DubboBeanDefinitionParser" class="headerlink" title="DubboBeanDefinitionParser"></a>DubboBeanDefinitionParser</h2><p>DubboBeanDefinitionParser.parse()中<br>根据 beanClass 创建 RootBeanDefinition,设置为非懒加载.<br>若未配置 id 属性,则会根据 name 或 interface 属性生成,并通过判断 BeanRegistry 中是否存在该 id 的 bean,用 则增序列解决重复问题.<br>通过id注册到BeanRegistry中,并设置 beanDefinition 的 id 属性.<br>下面就是对 ServiceBean 等元素的各自的属性配置的处理.</p><p>在Spring应用上下文启动过程中,加载XML配置文件(比如提供者配置和消费者配置文件)为 Resource 对象,并通过 XmlBeanDefinitionReader 调用BeanDefinitionParser 解析 XML 标签为 BeanDefinition,并注册到 BeanDefinitionRegistry 中.</p><h1 id="ServiceBean"><a href="#ServiceBean" class="headerlink" title="ServiceBean"></a>ServiceBean</h1><p>ServiceBean 实现了 InitializingBean, DisposableBean, ApplicationContextAware, <code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code>, BeanNameAware 这几个接口.</p><ol><li><p>实现的 ApplicationContextAware 接口的 setApplicationContext() 方法中,会:<br>保存 applicationContext 引用.<br>applicationContext 引用 保存到 SpringExtensionFactory 中.</p></li><li><p>实现的 InitializingBean 接口的 afterPropertiesSet() 方法中,会: 设置相关属性.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- ServiceBean.afterPropertiesSet()</span><br><span class="line">    - 从BeanFactory中获取ProviderConfig,ProtocolConfig等,这些bean是之前在Spring bean解析时加载进来的.将这些配置对象赋值到ServiceBean中,当然也有可能在其父类中.</span><br></pre></td></tr></table></figure></li><li><p>实现的 <code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code> 接口的 onApplicationEvent(ContextRefreshedEvent event) 方法中,有服务暴露的相关逻辑.</p></li></ol><h2 id="服务本地暴露"><a href="#服务本地暴露" class="headerlink" title="服务本地暴露"></a>服务本地暴露</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- ServiceBean.onApplicationEvent()</span><br><span class="line">    监听spring容器初始化完成时触发</span><br><span class="line">    - ServiceConfig.doExport()根据配置选择立即暴露或延迟暴露</span><br><span class="line">        - 暴露服务doExportUrls()</span><br><span class="line">            - loadRegistries(true)加载注册中心 URL 数组</span><br><span class="line">                - 将xml中配置的&lt;dubbo:registry&gt;解析成url对象(如registry:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?application&#x3D;demo-provider&amp;dubbo&#x3D;2.0.0&amp;logger&#x3D;jcl&amp;pid&#x3D;52008&amp;qos.port&#x3D;22222&amp;registry&#x3D;zookeeper&amp;timestamp&#x3D;1574666370052)</span><br><span class="line">            - doExportUrlsFor1Protocol(protocolConfig, registryURLs)根据不同的协议把服务export到不同的注册中心(如zk)上去</span><br><span class="line">                - ServiceConfig.exportLocal()中:服务本地暴露</span><br><span class="line">                    - 1.通过传入的协议url构造本地injvm协议的url</span><br><span class="line">                    - 2.通过proxyFactory.getInvoker()获取Invoker</span><br><span class="line">                        - ProxyFactory$Adaptive.getInvoker()方法</span><br><span class="line">                        - 1.ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory.class).getExtension(&quot;javassist&quot;)获取StubProxyFactoryWrapper 对象</span><br><span class="line">                        - 2.extension.getInvoker(arg0, arg1, arg2)通过ProxyFactory获取Invoker对象</span><br><span class="line">                            - StubProxyFactoryWrapper.getInvoker()直接调用内部的JavassistProxyFactory.getInvoker()</span><br><span class="line">                                - JavassistProxyFactory.getInvoker()方法中</span><br><span class="line">                                - 1.根据proxy对象创建Wrapper</span><br><span class="line">                                - 2.根据proxy, type, url创建AbstractProxyInvoker对象,它的doInvoke()方法会调用wrapper类的invokeMethod()方法</span><br><span class="line">                    - 3.protocol.export()将Invoker转为Exporter</span><br><span class="line">                        - Protocol$Adaptive.export()生成的代理类</span><br><span class="line">                            - 1.通过ExtensionLoader获取name为injvm的Protocol拓展对象.吐出的是ProtocolListenerWrapper的实例,包裹了InjvmProtocol</span><br><span class="line">                            - 2.extension.export(invoker)</span><br><span class="line">                                - ProtocolFilterWrapper.export()中</span><br><span class="line">                                    - 1.buildInvokerChain()建立带有 Filter 过滤链的 Invoker,再暴露服务</span><br><span class="line">                                    - 2.protocol.export()</span><br><span class="line">                                        - ProtocolListenerWrapper.export()中</span><br><span class="line">                                        - 1.通过InjvmProtocol.export()把invoker暴露为exporter</span><br><span class="line">                                            - InjvmProtocol.export()中</span><br><span class="line">                                            - 1.创建InjvmExporter对象</span><br><span class="line">                                        - 2.获取ExporterListener拓展对象列表</span><br><span class="line">                                        - 3.创建ListenerExporterWrapper对象作为exporter返回</span><br></pre></td></tr></table></figure><p>ServiceConfig.exportLocal()中:服务本地暴露<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exportLocal</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123; <span class="comment">// 协议不以injvm开头</span></span><br><span class="line">        <span class="comment">// 1.创建本地 injvm URL</span></span><br><span class="line">        URL local = URL.valueOf(url.toFullString())</span><br><span class="line">                .setProtocol(Constants.LOCAL_PROTOCOL) <span class="comment">// injvm</span></span><br><span class="line">                .setHost(LOCALHOST) <span class="comment">// 本地</span></span><br><span class="line">                .setPort(<span class="number">0</span>); <span class="comment">// 端口=0</span></span><br><span class="line">        ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));</span><br><span class="line">        <span class="comment">// 2.使用 ProxyFactory 创建 Invoker 对象</span></span><br><span class="line">        <span class="comment">// 3.使用 Protocol 暴露 Invoker 对象,将 Invoker 转成 exporter</span></span><br><span class="line">        Exporter&lt;?&gt; exporter = protocol.export(proxyFactory.getInvoker(ref, (Class) interfaceClass, local));</span><br><span class="line">        <span class="comment">// 添加到 `exporters`</span></span><br><span class="line">        exporters.add(exporter);</span><br><span class="line">        logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to local registry"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个 proxyFactory 是 ProxyFactory$Adaptive 对象,会根据传入的参数创建具体的 proxyFactory 对象.<br>proxyFactory.getInvoker(ref, (Class) interfaceClass, local)传入的参数分别是 服务具体实现类对象ref,服务接口DemoService,本地暴露的URL对象</p><p>ProxyFactory$Adaptive.getInvoker()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> com.alibaba.dubbo.rpc.<span class="function">Invoker <span class="title">getInvoker</span><span class="params">(java.lang.Object arg0, java.lang.Class arg1, com.alibaba.dubbo.common.URL arg2)</span> <span class="keyword">throws</span> com.alibaba.dubbo.rpc.RpcException </span>&#123;<span class="comment">// 获取Invoker.参数 arg0 为 ref 对象, arg1 为 服务接口(如 DemoService), args 为 服务暴露的 URL</span></span><br><span class="line">    <span class="keyword">if</span> (arg2 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">    com.alibaba.dubbo.common.URL url = arg2;</span><br><span class="line">    String extName = url.getParameter(<span class="string">"proxy"</span>, <span class="string">"javassist"</span>);<span class="comment">// 从url参数中获取 ProxyFactory 拓展使用的方式,默认是javassist</span></span><br><span class="line">    <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get extension(com.alibaba.dubbo.rpc.ProxyFactory) name from url("</span> + url.toString() + <span class="string">") use keys([proxy])"</span>);</span><br><span class="line">    com.alibaba.dubbo.rpc.ProxyFactory extension = (com.alibaba.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">extName</span>)</span>; <span class="comment">// 获取 ProxyFactory 接口 的拓展实现(默认使用的实现类为 JavassistProxyFactory)</span></span><br><span class="line">    <span class="keyword">return</span> extension.getInvoker(arg0, arg1, arg2);<span class="comment">// extension为StubProxyFactoryWrapper实例,包裹了JavassistProxyFactory对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过 <code>ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory.class).getExtension(&quot;javassist&quot;)</code> 获取的是 JavassistProxyFactory 对象,同时 ProxyFactory 有个 Wrapper 实现类 StubProxyFactoryWrapper,会被 SPI AOP 包装到 JavassistProxyFactory 对象 外层,所以最后吐出的是 StubProxyFactoryWrapper 对象.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.根据传入的 proxy 对象的类信息创建对它的包装对象 Wrapper</span></span><br><span class="line">    <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">'$'</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;<span class="comment">// 2.返回Invoker对象实例,这个invoker对象invoke()方法可以根据传入的invocation对象中包含的方法名,方法参数来调用proxy对象 返回调用结果</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Invoker -&gt; Exporter</p><p>ProtocolFilterWrapper.export()方法中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">// 注册中心</span></span><br><span class="line">    <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">        <span class="keyword">return</span> protocol.export(invoker); <span class="comment">// 向注册中心发布服务的时候并不会组装 filter 调用链</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立带有 Filter 过滤链的 Invoker,再暴露服务</span></span><br><span class="line">    <span class="keyword">return</span> protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建带 Filter 链的 Invoker 对象</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> invoker Invoker 对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key 获取 URL 参数名</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> group 分组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> &lt;T&gt; 泛型</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> Invoker 对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">buildInvokerChain</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>&#123;</span><br><span class="line">    Invoker&lt;T&gt; last = invoker;</span><br><span class="line">    <span class="comment">// 获得匹配激活的过滤器数组</span></span><br><span class="line">    List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter<span class="class">.<span class="keyword">class</span>).<span class="title">getActivateExtension</span>(<span class="title">invoker</span>.<span class="title">getUrl</span>(), <span class="title">key</span>, <span class="title">group</span>)</span>;</span><br><span class="line">    <span class="comment">// 倒序循环 Filter,创建带 Filter 链的 Invoker 对象</span></span><br><span class="line">    <span class="keyword">if</span> (!filters.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = filters.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> Filter filter = filters.get(i);</span><br><span class="line">            <span class="keyword">final</span> Invoker&lt;T&gt; next = last;</span><br><span class="line">            last = <span class="keyword">new</span> Invoker&lt;T&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> invoker.getInterface();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> invoker.getUrl();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> invoker.isAvailable();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> filter.invoke(next, invocation);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    invoker.destroy();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> invoker.toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProtocolListenerWrapper.export()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">// 注册中心协议</span></span><br><span class="line">    <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">        <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暴露服务,创建 Exporter 对象</span></span><br><span class="line">    Exporter&lt;T&gt; exporter = protocol.export(invoker);</span><br><span class="line">    <span class="comment">// 获得 ExporterListener 数组</span></span><br><span class="line">    List&lt;ExporterListener&gt; listeners = Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener<span class="class">.<span class="keyword">class</span>).<span class="title">getActivateExtension</span>(<span class="title">invoker</span>.<span class="title">getUrl</span>(), <span class="title">Constants</span>.<span class="title">EXPORTER_LISTENER_KEY</span>))</span>;</span><br><span class="line">    <span class="comment">// 创建带 ExporterListener 的 Exporter 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListenerExporterWrapper&lt;T&gt;(exporter, listeners);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>InjvmProtocol.export()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InjvmExporter&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用本地暴露的原因"><a href="#使用本地暴露的原因" class="headerlink" title="使用本地暴露的原因"></a>使用本地暴露的原因</h3><p>本地调用使用了 injvm 协议,是一个伪协议,它不开启端口,不发起远程调用,只在 JVM 内直接关联,但执行 Dubbo 的 Filter 链.</p><h2 id="服务远程暴露"><a href="#服务远程暴露" class="headerlink" title="服务远程暴露"></a>服务远程暴露</h2><p>服务远程暴露的总体流程:</p><p>1.将 ref 封装为 Invoker</p><p>2.将 Invoker 转换为 Exporter</p><p>3.启动 Netty 服务端</p><p>4.注册 provider 到 zk</p><p>5.zk 订阅与通</p><p>6.返回 Exporter 实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- 服务远程暴露</span><br><span class="line">- 使用 ProxyFactory 将 ref 创建成 Invoker 对象(这部分逻辑和本地暴露类似)</span><br><span class="line">    - ProxyFactory$Adaptive.getInvoker()中</span><br><span class="line">        - extension.getInvoker(arg0, arg1, arg2);</span><br><span class="line">            - StubProxyFactoryWrapper.getInvoker()直接调用内部的JavassistProxyFactory.getInvoker()</span><br><span class="line">                - JavassistProxyFactory.getInvoker()方法中</span><br><span class="line">                - 1.根据传入的 proxy对象(如DemoServiceImpl)的类信息创建对它的包装对象Wrapper</span><br><span class="line">                - 2.根据proxy, type, url创建AbstractProxyInvoker对象,它的doInvoke()方法会调用wrapper类的invokeMethod()方法</span><br><span class="line">- 首先将AbstractProxyInvoker实例包装成DelegateProviderMetaDataInvoker实例</span><br><span class="line">- 使用 Protocol 暴露 Invoker 对象为 Exporter</span><br><span class="line">    - Protocol$Adaptive.export()中</span><br><span class="line">    - 1.此时从传入的invoker.url.protocol获取到的协议为&quot;registry&quot;,获取到的Protocol拓展点实现类为包裹了DubboProtocol 对象的 ProtocolFilterWrapper</span><br><span class="line">    - 2.extension.export(invoker)</span><br><span class="line">        - ProtocolFilterWrapper.export()这个类在Invoker基础上添加filter链</span><br><span class="line">            - 1.因为传入的协议时&quot;registry&quot;,向注册中心暴露服务</span><br><span class="line">                - ProtocolListenerWrapper.export()中</span><br><span class="line">                - 1.调用RegistryProtocol.export(),向注册中心注册</span><br><span class="line">                    - RegistryProtocol.export()中</span><br><span class="line">                        - 1.doLocalExport()本地启动服务</span><br><span class="line">                            - RegistryProtocol.doLocalExport()中</span><br><span class="line">                            - 1.尝试从bounds缓存中获取exporter</span><br><span class="line">                            - 2.若1中获取不到则创建exporter并缓存</span><br><span class="line">                            - 3.根据invoker创建InvokerDelegete委托类,提供 获取 invoker 的方法</span><br><span class="line">                            - 4.调用Protocol$Adaptive.export()方法</span><br><span class="line">                                - Protocol$Adaptive.export()这次传入的协议是&quot;dubbo&quot;</span><br><span class="line">                                    - ProtocolFilterWrapper.export()中</span><br><span class="line">                                    - 1.buildInvokerChain()构建filter链</span><br><span class="line">                                    - 2.protocol.export()调用DubboProtocol.export()</span><br><span class="line">                                        - DubboProtocol.export()中</span><br><span class="line">                                        - 1.通过invoker创建DubboExporter</span><br><span class="line">                                        - &#x2F;&#x2F; 2.参见netty启动流程</span><br><span class="line">                            - 5.将4中返回的exporter包装成ExporterChangeableWrapper</span><br><span class="line">                        - 获取注册中心,如zk</span><br><span class="line">                            - 向注册中心注册自己</span><br><span class="line">                                - FailbackRegistry.register(url)</span><br></pre></td></tr></table></figure><p>ProtocolFilterWrapper.export()中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">// 注册中心</span></span><br><span class="line">    <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">        <span class="keyword">return</span> protocol.export(invoker);<span class="comment">// 向注册中心发布服务的时候并不会组装 filter调用链</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立带有 Filter 过滤链的 Invoker,再暴露服务</span></span><br><span class="line">    <span class="keyword">return</span> protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">// 暴露服务</span></span><br><span class="line">    <span class="comment">// export invoker</span></span><br><span class="line">    <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得注册中心 URL</span></span><br><span class="line">    URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得注册中心对象(启动zookeeper)</span></span><br><span class="line">    <span class="comment">// registry provider</span></span><br><span class="line">    <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得服务提供者 URL</span></span><br><span class="line">    <span class="keyword">final</span> URL registedProviderUrl = getRegistedProviderUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//to judge to delay publish whether or not.判断是否延迟发布</span></span><br><span class="line">    <span class="keyword">boolean</span> register = registedProviderUrl.getParameter(<span class="string">"register"</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向注册中心订阅服务消费者</span></span><br><span class="line">    ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registedProviderUrl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向注册中心注册服务提供者(自己)</span></span><br><span class="line">    <span class="keyword">if</span> (register) &#123;</span><br><span class="line">        register(registryUrl, registedProviderUrl);</span><br><span class="line">        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(<span class="keyword">true</span>); <span class="comment">// 标记向本地注册表的注册服务提供者,已经注册</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 OverrideListener 对象,订阅配置规则</span></span><br><span class="line">    <span class="comment">// Subscribe the override data</span></span><br><span class="line">    <span class="comment">// FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call the same service. Because the subscribed is cached key with the name of the service, it causes the subscription information to cover.</span></span><br><span class="line">    <span class="comment">// 创建订阅配置规则的 URL</span></span><br><span class="line">    <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);</span><br><span class="line">    <span class="comment">// 创建 OverrideListener 对象,并添加到 `overrideListeners` 中</span></span><br><span class="line">    <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    <span class="comment">// 向注册中心,发起订阅</span></span><br><span class="line">    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    <span class="comment">//Ensure that a new exporter instance is returned every time export</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;T&gt;(exporter, originInvoker, overrideSubscribeUrl, registedProviderUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>ExchangeHandlerAdapter 定义了与客户端连接成功／断开连接／接受到客户端消息／响应消息,以及创造Invocation的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeServer(Transporters.bind(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>HeaderExchangeHandler: 基于消息头(Header)的信息交换服务器实现类</p><p>DecodeHandler: 解码处理器,处理接收到的消息</p><h3 id="Netty-启动流程"><a href="#Netty-启动流程" class="headerlink" title="Netty 启动流程"></a>Netty 启动流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- netty启动流程</span><br><span class="line">- openServer(url)启动通信服务器(如Netty)</span><br><span class="line">    - DubboProtocol.openServer()中</span><br><span class="line">        - DubboProtocol.createServer()中</span><br><span class="line">        - 1.创建ExchangeHandlerAdapter实例,作为请求处理器</span><br><span class="line">        - 2.Exchangers.bind(url,requestHandler)</span><br><span class="line">            - Exchangers.bind()中</span><br><span class="line">            - 1.根据url获取Exchanger,返回的是HeaderExchanger对象</span><br><span class="line">                - HeaderExchanger.bind()</span><br><span class="line">                    - HeaderExchanger.bind()方法中</span><br><span class="line">                    - 1. return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))))会对传入的ExchangeHandlerAdapter包装两层,然后使用Transporters.bind()创建NettyServer对象.</span><br><span class="line">                        - Transporters.bind()中</span><br><span class="line">                        - 1.返回Transporter的适配对象</span><br><span class="line">                        - 2.调用Transporter$Adaptive.bind()</span><br><span class="line">                            - netty4&#x2F;NettyTransporter.bind()通过new NettyServer(url, listener)创建nettyServer对象</span><br><span class="line">                                - NettyServer(url,handler)构造器中会通过ChannelHandlers会传入的DecodeHandler进行包装</span><br><span class="line">                                    - ChannelHandler.wrapInternal()方法中</span><br><span class="line">                                    - 1.获取Dispatcher的适配对象</span><br><span class="line">                                    - 2.调用Dispatcher.dispatch(handler, url)</span><br><span class="line">                                        - AllDispatcher.dispatch()中new AllChannelHandler(handler, url)</span><br><span class="line">                                            - AllChannelHandler调用父类构造方法WrappedChannelHandler</span><br><span class="line">                                                - WrappedChannelHandler()构造方法中</span><br><span class="line">                                                - 1.创建线程池</span><br><span class="line">                                    - 3.把2中的返回结果用HeartbeatHandler和MultiMessageHandler再包装</span><br><span class="line">                                - NettyServer.doOpen()</span><br><span class="line">                - 1.创建</span><br><span class="line">            - 2.exchanger.bind()</span><br><span class="line">    - ExchangeServer.createServer() 创建ExchangeServer</span><br></pre></td></tr></table></figure><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZookeeperRegistry</span><span class="params">(URL url, ZookeeperTransporter zookeeperTransporter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(url);</span><br><span class="line">    <span class="keyword">if</span> (url.isAnyHost()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"registry address == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获得 Zookeeper 根节点</span></span><br><span class="line">    String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT); <span class="comment">// `url.parameters.group` 参数值</span></span><br><span class="line">    <span class="keyword">if</span> (!group.startsWith(Constants.PATH_SEPARATOR)) &#123;</span><br><span class="line">        group = Constants.PATH_SEPARATOR + group;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.root = group;</span><br><span class="line">    <span class="comment">// 创建 Zookeeper Client</span></span><br><span class="line">    zkClient = zookeeperTransporter.connect(url);</span><br><span class="line">    <span class="comment">// 添加 StateListener 对象.该监听器,在重连时,调用恢复方法.</span></span><br><span class="line">    zkClient.addStateListener(<span class="keyword">new</span> StateListener() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (state == RECONNECTED) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    recover();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractRegistry: </p><ul><li>1.通用的注册,订阅,查询,通知等方法</li><li>2.读取和持久化注册数据到文件,以 properties 格式存储</li></ul><p>FailbackRegistry:<br>主要用来做失败重试操作(包括: 注册失败,反注册失败,订阅失败,反订阅失败,通知失败的重试);也提供了供 ZookeeperRegistry 使用的 zk 重连后的恢复工作的方法.</p><p>ZookeeperRegistry:<br>创建 zk 客户端,启动会话;并且调用 FailbackRegistry 实现 zk 重连后的恢复工作.</p><h3 id="注册到-zk-流程"><a href="#注册到-zk-流程" class="headerlink" title="注册到 zk 流程"></a>注册到 zk 流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- 注册到zk流程</span><br><span class="line">- RegistryProtocol.export()</span><br><span class="line">- 1.获得注册中心 URL</span><br><span class="line">    - 就是把url改为zookeeper:&#x2F;&#x2F;协议开头</span><br><span class="line">- 2.获得注册中心对象(启动zookeeper),通过ZookeeperRegistryFactory实例创建并返回ZookeeperRegistry对象</span><br><span class="line">    - AbstractRegistryFactory.getRegistry(url)中</span><br><span class="line">    - 1.加锁 从缓存中获得 Registry 对象</span><br><span class="line">    - 2.若获取不到,则createRegistry(url)创建 Registry 对象并缓存</span><br><span class="line">        - ZookeeperRegistryFactory.createRegistry()中会new ZookeeperRegistry(url, zookeeperTransporter)创建ZookeeperRegistry实例</span><br><span class="line">- 3.获得服务提供者 URL</span><br><span class="line">- 4.向注册中心注册服务提供者</span><br><span class="line">    - RegistryProtocol.register(registedProviderUrl)</span><br><span class="line">    - 1.从registryFactory中获取registry</span><br><span class="line">    - 2.registry.register()</span><br><span class="line">        - ZookeeperRegistry.doRegister()</span><br><span class="line">        - 1.通过url得到zk路径,创建临时节点</span><br><span class="line">- 5.向注册中心发起订阅</span><br><span class="line">    当前的provider订阅了&#x2F;dubbo&#x2F;com.alibaba.dubbo.demo.DemoService&#x2F;configurators,当其下的子节点发生变化(url)时,通知到provider,使得providerUrl发生变化,则提供者需要重新暴露</span><br><span class="line">    - RegistryProtocol.export()</span><br><span class="line">        - FailbackRegistry.subscribe()</span><br><span class="line">            - ZookeeperRegistry.doSubscribe()</span><br><span class="line">            - 创建持久节点&#x2F;dubbo&#x2F;com.alibaba.dubbo.demo.DemoService&#x2F;configurators</span><br><span class="line">- 6.返回Exporter</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Dubbo-与-Spring-的结合&quot;&gt;&lt;a href=&quot;#Dubbo-与-Spring-的结合&quot; class=&quot;headerlink&quot; title=&quot;Dubbo 与 Spring 的结合&quot;&gt;&lt;/a&gt;Dubbo 与 Spring 的结合&lt;/h1&gt;&lt;p&gt;代码在 du
      
    
    </summary>
    
      <category term="Dubbo" scheme="http://yoursite.com/categories/Dubbo/"/>
    
    
      <category term="Dubbo" scheme="http://yoursite.com/tags/Dubbo/"/>
    
  </entry>
  
</feed>
